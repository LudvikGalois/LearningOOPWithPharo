% -*- mode: latex; -*- mustache tags:  
\documentclass[10pt,twoside,english]{_support/latex/sbabook/sbabook}
\let\wholebook=\relax

\usepackage{import}
\subimport{_support/latex/}{common.tex}

%=================================================================
% Debug packages for page layout and overfull lines
% Remove the showtrims document option before printing
\ifshowtrims
  \usepackage{showframe}
  \usepackage[color=magenta,width=5mm]{_support/latex/overcolored}
\fi


% =================================================================
\title{Learning Object-Oriented Programming, Design and TDD with Pharo}
\author{Stéphane Ducasse}
\series{The Pharo TextBook Collection}

\hypersetup{
  pdftitle = {Learning Object-Oriented Programming, Design and TDD with Pharo},
  pdfauthor = {Stéphane Ducasse},
  pdfkeywords = {Introduction, programming, design, testing, Pharo, Smalltalk}
}


% =================================================================
\begin{document}

% Title page and colophon on verso
\maketitle
\pagestyle{titlingpage}
\thispagestyle{titlingpage} % \pagestyle does not work on the first one…

\cleartoverso
{\small

  Copyright 2017 by Stéphane Ducasse.

  The contents of this book are protected under the Creative Commons
  Attribution-ShareAlike 3.0 Unported license.

  You are \textbf{free}:
  \begin{itemize}
  \item to \textbf{Share}: to copy, distribute and transmit the work,
  \item to \textbf{Remix}: to adapt the work,
  \end{itemize}

  Under the following conditions:
  \begin{description}
  \item[Attribution.] You must attribute the work in the manner specified by the
    author or licensor (but not in any way that suggests that they endorse you
    or your use of the work).
  \item[Share Alike.] If you alter, transform, or build upon this work, you may
    distribute the resulting work only under the same, similar or a compatible
    license.
  \end{description}

  For any reuse or distribution, you must make clear to others the
  license terms of this work. The best way to do this is with a link to
  this web page: \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/}

  Any of the above conditions can be waived if you get permission from
  the copyright holder. Nothing in this license impairs or restricts the
  author's moral rights.

  \begin{center}
    \includegraphics[width=0.2\textwidth]{_support/latex/sbabook/CreativeCommons-BY-SA.pdf}
  \end{center}

  Your fair dealing and other rights are in no way affected by the
  above. This is a human-readable summary of the Legal Code (the full
  license): \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/legalcode}

  \vfill

  % Publication info would go here (publisher, ISBN, cover design…)
  Layout and typography based on the \textcode{sbabook} \LaTeX{} class by Damien
  Pollet.
}


\frontmatter
\pagestyle{plain}

\tableofcontents*
\clearpage\listoffigures

\mainmatter

\chapter{Inheritance: Incremental definition and behavior reuse}\label{cha:inheritance}
In Chapter \ref{cha:objectclass}, we presented objects and classes. Objects are entities that communicate exclusively by sending and receiving messages. Objects are described by classes that are factories of objects. Classes define behavior and structure of all their instances: All the instances of a class share the same behavior but have their own private state. 

In this chapter we present the fundamental concept of  \textit{inheritance} that allows a class to reuse and extend the behavior of another class. The idea is that as a programmer we do not want to rewrite from scratch a functionality if another class already offers it. A program specialises the implemented behavior into the new behavior he wants. Inheritance lets us express this concept specialisation.  Using inheritance we create trees of concepts where more precise ones refine more abstract and generic ones. 

Inheritance is based on dynamic method lookup: a method is looked up dynamically within the inheritance tree starting from the class of the receiver. Once this explained we will show that it is possible to get code of a subclass invoked in place of the one of a superclass. 

To illustrate the important points of inheritance, we revisit the example of Chapter \ref{cha:objectclass}. 
\section{Inheritance}
Object-oriented programming is also based on the \textit{incremental} definition of abstractions. This \textit{incremental} definition mechanism is central to support reuse and extension of abstraction. It is called \textit{inheritance}. The idea is that you can define a new abstraction (a class) by refining an existing one (its superclass). We said that a subclass inherits from a superclass. This way we reuse the code of the superclass instead of rewriting everything from scratch.

Class inheritance creates trees of classes. Such trees are based on \textit{generalisation}: a superclass is more generic than its subclasses. A class in such trees can have instances. All the instances share the behavior defined in their class and superclasses.
This is within such trees that the system looks up the method corresponding to a message sent to an instance of a class.

Inheritance supports code reuse because instance variable and methods defined in a root concept (class) are applicable to its refinements (subclasses).


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/FileDirectoryV1.pdf}\caption{Two classes understanding similar sets of messages and structuring their instances in a similar way.\label{FileDirectoryV1}}\end{center}
\end{figure}


We will use and extend the simple and naive example of files and directories (seen in Chapter \ref{cha:objectclass}) to illustrate the key aspects of inheritance. While simple, it is enough to show the key properties of inheritance that we want to illustrate: 

\begin{itemize}
\item \textit{incremental definition}: a subclass is defined by expressing the difference to its superclass. A subclass specialises its superclass behavior.
\item \textit{state reuse}: instances of a subclass have at least the state structure of the superclass.
\item \textit{behavior reuse}: upon message reception instances,  when the class of the receiver does not define a method, methods of the superclasses are executed instead.
\item \textit{behavior redefinition (overriding)}: a subclass may change locally a method definition inherited from its superclass.
\item \textit{behavior extension}: a subclass often extends the behavior of one of its superclasses by defining new methods and state.
\item \textit{subclass behavior can be invoked instead of superclass behavior}: behavior defined in a subclass may be executed in place of the one of a superclass. It means that with behavior overriding subclass behavior can be invoked in place of superclass behavior. This is a really important feature of inheritance.
\end{itemize}
\section{Improving files/directories example design}
Let us go back to the example of files and directories introduced in previous chapter. 
When we look at the situation depicted by Figure \ref{FileDirectoryV1} we see that a file is not the same as a directory, even though they share some common state: both have a name and a parent. In addition, they understand some common messages such as \textcode{size}, \textcode{search:}, \textcode{parent:} and \textcode{name:}. Remember that \textcode{size} and \textcode{search:} were not implemented the same way but the messages have indeed the same name. 

Load the code so that you can get the tests that we asked you to define at the end of chapter \ref{cha:objectclass}.

\begin{displaycode}{plain}
Gofer new
	smalltalkhubUser: 'StephaneDucasse' project: 'Loop'; 
	version: 'MyFS2-StephaneDucasse.4';
	load
\end{displaycode}

Verify that the tests are all passing (green).
\subsection{Objectives}
In the following sections we will take advantage of defining a common superclass and reuse its definition as shown in Figure \ref{FileDirectoryWithInheritanceObjective}: It means sharing the maximum structure and behavior between the two classes. We will proceed step by step so that you can see all the steps and understand why this is working.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/FileDirectoryWithInheritanceObjective.pdf}\caption{Two class taking advantages of inheriting from a common superclass.\label{FileDirectoryWithInheritanceObjective}}\end{center}
\end{figure}

\section{Transformation strategies}
Let us define a new class called \textcode{MFElement}. 

\begin{displaycode}{plain}
Object subclass: #MFElement
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'MyFS2'
\end{displaycode}

As you may noticed it, this class is empty. Now we have two possible strategies: 

\begin{itemize}
\item either we make \textcode{MFFile} and \textcode{MFDirectory} inherit from \textcode{MFElement} and  step by step we migrate the common state and behavior to the superclass,
\item or we define new state and behavior in \textcode{MFElement} and we remove it  from the two classes and when ready we make them inherit from \textcode{MFElement}. 
\end{itemize}

The second approach may work but it is too risky. Indeed with the first approach we can get a running system after any step we perform: why? Because we first inherit from the new class and move element from the subclasses to the classes and doing so we automatically reuse the superclass behavior and state so our program externally (for example from the test perspective) is not changed. With such an approach we can run our tests after any change and control our enhancements.

In addition, some of the operations such as moving an instance variable from a class to its superclass are tedious to perform. Here we will perform one operation manually but for the rest of the changes we will use \textit{refactorings} -- refactorings are program transformations that keep the behavior of the program the same.

Let us get started.
\section{Factoring out state}
The first step is to make \textcode{MFFile} and \textcode{MFDirectory} subclasses of \textcode{MFElement} as follows:

\begin{displaycode}{plain}
MFElement subclass: #MFFile
	instanceVariableNames: 'parent name contents'
	classVariableNames: ''
	package: 'MyFS2'
\end{displaycode}

\begin{displaycode}{plain}
MFElement subclass: #MFDirectory
	instanceVariableNames: 'parent name files'
	classVariableNames: ''
	package: 'MyFS2'
\end{displaycode}

Now you can execute the tests and they will all pass. Now we get ready move some instance variables to the superclass.


\begin{figure}

\begin{center}
\includegraphics[width=0.5\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/FileDirectoryInhStateNameOnly.pdf}\caption{Moving the instance variable name to the superclass.\label{FileDirectoryInhStateNameOnly}}\end{center}
\end{figure}

\subsection{Moving instance variable name to superclass}
Since both \textcode{MFDirectory} and \textcode{MFFile} define that their instances should have a name, we can remove the instance variable \textcode{name} from them and uniquely define it in the superclass. We obtain the situation depicted in Figure \ref{FileDirectoryInhStateNameOnly}.
Let us do that as follows: We remove it first from the \textcode{MFFile} and \textcode{MFDirectory} classes.

\begin{displaycode}{plain}
MFElement subclass: #MFFile
	instanceVariableNames: 'parent contents'
	classVariableNames: ''
	package: 'MyFS2'
\end{displaycode}

\begin{displaycode}{plain}
MFElement subclass: #MFDirectory
	instanceVariableNames: 'parent files'
	classVariableNames: ''
	package: 'MyFS2'
\end{displaycode}

And we add the instance variable \textcode{name} to the superclass \textcode{MFElement}.

\begin{displaycode}{plain}
Object subclass: #MFElement
	instanceVariableNames: 'name'
	classVariableNames: ''
	package: 'MyFS2'
\end{displaycode}

Pay attention that you should be careful and do it in this order else you may be in the situation where name will be defined in the superclass and in one of the subclasses and the system does not allow this and will forbid your action. 

Again run the tests they should pass again. 

What the tests execution proves is that we did not change the structure of the instances of \textcode{MFFile} and \textcode{MFDirectory}. Indeed the structure of an instance is computed from the instance variable lists defined in their class and all the superclasses of that class.
\subsection{Moving parent to superclass}
Since parent is defined in both subclasses, we can do the same for the instance variable parent to obtain the situation shown in Figure \ref{FileDirectoryInhFullStateOnly}.
You can do it manually, as we did for the instance variable \textcode{name}, but you can also use a \textit{refactoring}: Refactorings are powerful program transformations. Using the system browser, bring the menu on the class \textcode{MFFile}, select refactoring, then the instance variable category, and finally pull up, as shown in Figure \ref{Refactoring}.


\begin{figure}

\begin{center}
\includegraphics[width=0.6\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/Refactoring.png}\caption{Applying the Pull Up Instance variable refactoring.\label{Refactoring}}\end{center}
\end{figure}


The system will ask you which variable you want to pull up, select \textcode{parent}. It will show you the changes that it is about to perform: removing the instance variable from both subclasses and adding one to the superclass. Proceed and the changes will be executed. Your
code should be now in the situation depicted in Figure \ref{FileDirectoryInhFullStateOnly}.
Run the tests and they should again all pass!


\begin{figure}

\begin{center}
\includegraphics[width=0.5\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/FileDirectoryInhFullStateOnly.pdf}\caption{State factored between the two classes and their superclass.\label{FileDirectoryInhFullStateOnly}}\end{center}
\end{figure}


What is important to see is that if we create a new subclass of \textcode{MFElement}, the instances of such class will automatically get \textcode{name} and \textcode{parent} as instance variables. This is one of the key property of inheritance: you can define a new abstraction structure by extending an existing one. 

Now we can do the same for the behavior: we will move similar methods in the superclass and remove them from their respective classes. 
\section{Factoring similar methods}
The methods \textcode{parent:}, \textcode{parent} and \textcode{name:} are the same and defined in the two classes \textcode{MFFile} and \textcode{MFDirectory}. We will move them to the superclass \textcode{MFElement} following a similar process.

\begin{itemize}
\item First we will remove the method \textcode{name:} from the two classes \textcode{MFFile} and \textcode{MFDirectory} and add one version to the class \textcode{MFElement}. You can do this manually. 
\end{itemize}

\begin{itemize}
\item Second for the method \textcode{parent:}, use the method Refactoring \textit{Push Up Method} that is available from the method list.  You can repeat this for the method \textcode{parent} too. 
\end{itemize}

You should obtain the system described in Figure \ref{FileDirectoryInhAccessors}.


\begin{figure}

\begin{center}
\includegraphics[width=0.5\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/FileDirectoryInhAccessors.png}\caption{ State and Methods factored out in the superclass.\label{FileDirectoryInhAccessors}}\end{center}
\end{figure}


Again run the tests and they should all pass. Why? Let us see what is happening when we send a message.
\section{Sending a message and method lookup }

\begin{figure}

\begin{center}
\includegraphics[width=0.5\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/BasicLookupAndExecution.png}\caption{When an object receives a message, the corresponding method is looked up in its class and if necessary its superclasses (Step 1 and 2). Then the method is executed on the message receiver (Step 3).\label{BasicLookup}}\end{center}
\end{figure}


Now it is time to explain what is happening when an object receives a message. In fact this is really simple but extremely powerful. When a message is sent to an object, first the corresponding method is looked up and once the method is found, it is executed on the object that initially received the message. 

\begin{itemize}
\item \textbf{Method Lookup}. When an object, the message receiver, receives a message, the method with the same selector than the message is looked up starting from the \textit{class} of receiver (See step 1 in Figure \ref{BasicLookup}). When there is no method with the same selector, the look up continues in the superclass of the current class (See step 2 in Figure \ref{BasicLookup}).
\item \textbf{Method execution}. When a method with the same selector is found in a class, it is returned and executed on the receiver of the message (See step 3 in Figure \ref{BasicLookup}). 
\end{itemize}

Let us look at our example. 

\begin{itemize}
\item When we send the message \textcode{astroboy parent: oldcomics}, the method named \textcode{parent:} is looked up in the class of the receiver i.e., \textcode{MFFile}. This class defines such a method, so it is returned and executed on the file \textcode{astroboy}.
\end{itemize}

\begin{itemize}
\item The tests pass because when we send the message \textcode{parent:} to an instance of the class \textcode{MFFile}, the corresponding method is looked up in the class \textcode{MFFile}. Since there is no method \textcode{parent:} in the class \textcode{MFFile}, the lookup continues in the superclass and find it in the class \textcode{MFElement} as shown in Figure \ref{BasicLookup}.
\end{itemize}
\subsection{Inheritance properties}
While rather simple, the previous example shows some key properties of inheritance. 

Inheritance is a mechanism to define abstraction incrementally: a subclass is defined by expressing the difference to its superclass. A subclass refines a general concept into a more specific one. The classes \textcode{MFFile} and \textcode{MFDirectory} add extra behavior and state to the one defined in the superclass. As such they reuse the state and behavior of their superclass.

\begin{itemize}
\item \textit{State reuse}: instances of a subclass have at least the structure of their superclasses (\textcode{name} and \textcode{parent}), local state can be added in addition (\textcode{contents} and \textcode{files}).
\end{itemize}

\begin{itemize}
\item \textit{Behavior reuse}: when instances of a subclass receive a message, methods of the superclass may be executed. The method \textcode{parent:}, \textcode{parent}, and \textcode{name} are defined in \textcode{MFElement} but are executed on instances of the subclasses.
\end{itemize}

Inheritance creates trees of refined concepts. A superclass represents a more abstract concepts and its subclasses make it more and more specific by refining the superclass behavior or extending it by adding new behavior. 
\section{Basic method overrides}
Since the method lookup starts from the class of the receiver, redefining a method in subclass takes precedence over the method defined in the superclasses.

If we define a method with the same name that one of its superclass, this new method will be executed instead of the one in the superclass. This is called a \textit{method override}. This is useful to be able to redefine locally a behavior taking advantage of the specificities of the subclasses. In Figure \ref{BasicLookup}, if we add a new method named \textcode{parent:} in the class \textcode{MFFile}, this method will be executed when the message \textcode{parent:} is sent to an instance of the class \textcode{File}. 

We will see later that we can also invoke the method of the superclass while doing a method overrides: it is useful when we want to \textit{extend} and not just fully change the superclass behavior. 

But before explaining this, method lookup and execution are systematically applied and we will see in the following sections that it is even more powerful than it may look at first sight.
\section{self-send messages and lookup create hooks}
So far we explained how a message is resolved: first the corresponding method is looked up from the class of the receiver and goes up the inheritance tree. Second, the found method is executed on the message receiver. It means that in response to a message, a superclass method may be executed on its subclass instances. This is the same for message sent to \textcode{self} (the receiver of the message), we invoke the method lookup and \textcode{self} may be one subclass instances.

There is an important implication: when we have a message sent to \textcode{self} in a method, this message may lead to the execution of a method defined in subclasses: because a subclass may override such method. This is why self-sends are also called \textit{hooks} methods. We will explain carefully this point. 
\subsection{Example}
To explain precisely this important point, let us define a new little behavior: to build a better user interface for end-users we add a new message called \textcode{describe} that presents in more human friendly way the receiver of the message.
Here is a small example: 

\begin{displaycode}{plain}
| p el1 el2 |
p := MFDirectory new name: 'comics'.
el1 := MFFile new name: 'babar'; contents: 'Babar et Celeste'.
p addElement: el1.
el2 := MFFile new name: 'astroboy'; contents: 'super cool robot'.
p addElement: el2.
p describe
>>> 'I m a directory named comics'
el1 describe
>>> 'I m a file named babar'
\end{displaycode}
\subsection{Describe implementation }
We implement now the situation described by Figure \ref{fig:SelfSendLateBinding}.
To implement this behavior, we define the following method \textcode{describe} in the class \textcode{MFElement}.

\begin{displaycode}{plain}
MFElement >> describe
	^ 'I m a ', self kind, 'named ', name  
\end{displaycode}

We define the method \textcode{kind} to return a default string, even though we do not expect 
to create instances of this class and subclasses should define their own definition.

\begin{displaycode}{plain}
MFElement >> kind
	^ 'element'
\end{displaycode}

In each of the subclasses, we define a corresponding method \textcode{kind}, as follows: 

\begin{displaycode}{plain}
MFDirectory >> kind
	^ 'directory'
\end{displaycode}

\begin{displaycode}{plain}
MFFile >> kind
	^ 'file'
\end{displaycode}
\section{Hook/Template explanations}
Now we are ready to explain what is happening. Let us illustrate the execution of the \textcode{(MFFile new name: 'astroboy') describe}.

\begin{displaycode}{plain}
| el1 |
el1 := (MFFile new name: 'astroboy').
el1 describe
>>> 'I m a file named astroboy'
\end{displaycode}

The following steps are executed: 

\begin{itemize}
\item The message \textcode{describe} is sent to \textcode{el1} an instance of the class \textcode{MFFile}. 
\item The method \textcode{describe} is looked up in the class \textcode{MFFile} (step 1 in Figure \ref{fig:SelfSendLateBinding}). It is not found, therefore the lookup continues to the superclass. 
\item The lookup looks for the method \textcode{describe} in the class \textcode{MFElement}  (step 2 in Figure \ref{fig:SelfSendLateBinding}). It is found and executed on the receiver: \textcode{el1}. 
\item During the execution of the method \textcode{describe}, a new message \textcode{kind} using the expression \textcode{self kind} is sent (step 3 in Figure \ref{fig:SelfSendLateBinding}).
\item The message \textcode{kind} is looked up starting from the class of the receiver, \textcode{MFFile} (step 4 in Figure \ref{fig:SelfSendLateBinding}). The method \textcode{kind} is found in class \textcode{MFFIle} and executed. 
\item The rest of the method \textcode{describe} is executed and the resulting string is returned.
\end{itemize}


\begin{figure}

\begin{center}
\includegraphics[width=0.65\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/SelfSendLateBinding.png}\caption{A self-send creates a hook (\textcode{kind}) that subclasses override. The method \textcode{ describe} is called a template because it creates a context.\label{fig:SelfSendLateBinding}}\end{center}
\end{figure}


A vocabulary point: the method \textcode{describe} is called a \textit{template} method because it creates a context in which the \textcode{kind} methods are executed. The message \textcode{kind} is called a hook since subclass implementation may be invoked in this place.

This example illustrates the following important points:

\begin{itemize}
\item Each time we send a message the system chooses the correct method to be executed.
\item Each time we send a self-send message we create a place where subclass methods may be executed. We create customization points.
\item Since \textcode{self} represents the receiver and that receiver may be an instance from a class that is not loaded at the time the method containing the self-send, we say that \textcode{self} is dynamic. It represents the receiver of the message and the lookup for the method to execute starts in the class of the receiver. 
\end{itemize}

\begin{important}
Messages sent to the receiver (\textcode{self} sends) define customization points that subclasses can take advantage of to potentially see their code being executed in place of the superclass' one.
\end{important}
\section{Essence of self and dispatch}
Now we take some time to look abstractly at what we presented so far. 
Imagine a situation as illustrated by Figure \ref{fig:LookupWithSelfInSuperclassMethod}.

The first questions are simple and should be not a problem for you. Without looking at the solutions guess what are the results of the following messages.

\begin{displaycode}{plain}
A new foo
>>> ... 
B new foo
>>> ...
\end{displaycode}

What is more interesting is the process to get the result of \textcode{B new bar}.

\begin{displaycode}{plain}
A new bar
>>> ...
B new bar
>>> ...
\end{displaycode}


\begin{figure}

\begin{center}
\includegraphics[width=0.35\textwidth]{/Users/ducasse/Workspace/FirstCircle/MyBooks/Bk-Writing/PharoBooks/LearningOOPWithPharoTrans/_result/pdf/Chapters/Inheritance/figures/LookupWithSelfInSuperclassMethod.pdf}\caption{Self semantics abstractly explained.\label{fig:LookupWithSelfInSuperclassMethod}}\end{center}
\end{figure}

\subsection{Solutions}
The solutions are the following ones.

\begin{displaycode}{plain}
A new foo
>>> 10

B new foo
>>> 50

A new bar
>>> 10

B new bar
>>> 50
\end{displaycode}

The most interesting one is \textcode{B new bar}.  Let us look at the execution of \textcode{aB bar}

\begin{enumerate}
\item \textcode{aB}'s class is \textcode{B}.
\item The method look up starts in the class \textcode{B}.
\item There is no method \textcode{bar} in \textcode{B}.
\item The look up continues in \textcode{A} and method \textcode{bar} is found.
\item The method \textcode{bar} is executed on the receiver  \textcode{aB}.
\item \textcode{self} refers to the receiver \textcode{aB}.
\item The message \textcode{foo} is sent to \textcode{self}.
\item The look up of \textcode{foo} starts in the \textcode{aB}'s class: \textcode{B}.
\item The method \textcode{foo} is found in class \textcode{B} and executed on the receiver \textcode{aB}.
\end{enumerate}

\begin{important}
\textcode{self} represents the receiver. Messages sent to it are looked up from the class of the receiver. 
\end{important}
\section{Instance variables vs. messages}
Reading the previous section you should now understand that there is in fact a difference between accessing directly an instance variable such as \textcode{name} in the method below and using an accessor as illustrated in the next redefinition. 

The two following method definitions are doing the same but have different extensibility potential.

\begin{displaycode}{plain}
MFElement >> describe
	^ 'I m a ', self kind, 'named ', name  
\end{displaycode}

\begin{displaycode}{plain}
MFElement >> describe
	^ 'I m a ', self kind, 'named ', self name  
\end{displaycode}

When you use an accessor, subclasses may redefine the behavior of the accessors.

\begin{displaycode}{plain}
MFElement >> name
	^ name
\end{displaycode}

There is no systematic rule that states that we should systematically use accessors instead of instance variable access. 

What is important when you decide to use an accessor is to use it consistently. Indeed 
if some parts use direct instance variable access and other parts use accessors, then a programmer extending your code may redefine the accessors in a subclass and his code may not be invoked (for example if you left places where you directly access an instance variable).

In addition when you decide to use in your class an accessor it is also better that you do so for all the instance variables of the class. Else we may wonder why and uniformity makes the code more understandable.
\section{Conclusion}
We presented the concept of inheritance: a subclass is defined as a refinement of a superclass. It reuses the superclass behavior and may extend the structure its instances will have. We show that method lookup happens dynamically and walks the inheritance tree starting from the receiver class.
We show that self-sends are creating hooks in the sense that subclass methods may be executed in place of the superclass counterpart. 

In the following chapter we will see that we can reuse even more methods between all the superclass and its subclasses.


% lulu requires an empty page at the end. That's why I'm using
% \backmatter here.
\backmatter

% Index would go here
\bibliographystyle{abbrv}
\bibliography{others.bib}
\end{document}
