% -*- mode: latex; -*- mustache tags:  
\documentclass[10pt,twoside,english]{_support/latex/sbabook/sbabook}
\let\wholebook=\relax

\usepackage{import}
\subimport{_support/latex/}{common.tex}

%=================================================================
% Debug packages for page layout and overfull lines
% Remove the showtrims document option before printing
\ifshowtrims
  \usepackage{showframe}
  \usepackage[color=magenta,width=5mm]{_support/latex/overcolored}
\fi


% =================================================================
\title{Learning Object-Oriented Programming, Design and TDD with Pharo}
\author{Stéphane Ducasse}
\series{The Pharo TextBook Collection}

\hypersetup{
  pdftitle = {Learning Object-Oriented Programming, Design and TDD with Pharo},
  pdfauthor = {Stéphane Ducasse},
  pdfkeywords = {Introduction, programming, design, testing, Pharo, Smalltalk}
}


% =================================================================
\begin{document}

% Title page and colophon on verso
\maketitle
\pagestyle{titlingpage}
\thispagestyle{titlingpage} % \pagestyle does not work on the first one…

\cleartoverso
{\small

  Copyright 2017 by Stéphane Ducasse.

  The contents of this book are protected under the Creative Commons
  Attribution-ShareAlike 3.0 Unported license.

  You are \textbf{free}:
  \begin{itemize}
  \item to \textbf{Share}: to copy, distribute and transmit the work,
  \item to \textbf{Remix}: to adapt the work,
  \end{itemize}

  Under the following conditions:
  \begin{description}
  \item[Attribution.] You must attribute the work in the manner specified by the
    author or licensor (but not in any way that suggests that they endorse you
    or your use of the work).
  \item[Share Alike.] If you alter, transform, or build upon this work, you may
    distribute the resulting work only under the same, similar or a compatible
    license.
  \end{description}

  For any reuse or distribution, you must make clear to others the
  license terms of this work. The best way to do this is with a link to
  this web page: \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/}

  Any of the above conditions can be waived if you get permission from
  the copyright holder. Nothing in this license impairs or restricts the
  author's moral rights.

  \begin{center}
    \includegraphics[width=0.2\textwidth]{_support/latex/sbabook/CreativeCommons-BY-SA.pdf}
  \end{center}

  Your fair dealing and other rights are in no way affected by the
  above. This is a human-readable summary of the Legal Code (the full
  license): \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/legalcode}

  \vfill

  % Publication info would go here (publisher, ISBN, cover design…)
  Layout and typography based on the \textcode{sbabook} \LaTeX{} class by Damien
  Pollet.
}


\frontmatter
\pagestyle{plain}

\tableofcontents*
\clearpage\listoffigures

\mainmatter

\chapter{Variations around Isograms}
This chapter propose some little challenges around words and sentences as a way to explore Pharo collections.
\section{A dictionary-based solution}
\begin{todo}
blbl
\end{todo}

\begin{displaycode}{plain}
String >> isIsogramDictionaryImplementation
	"'ALTRUISME' isIsogramDictionaryImplementation"
	| letters |
	letters := Dictionary new. 
	self do: [ :aChar |
			letters at: aChar 
				ifPresent: [^ false] 
				ifAbsent: [ letters at: aChar put: 1]. 
			].
	^ true
\end{displaycode}
\section{A Bag-based solution}
\begin{todo}
blbl
\end{todo}

\begin{displaycode}{plain}
String >> isIsogramUsingBagImplementation
	"'ALTRUISME' isIsogramUsingBagImplementation"
	
	| bag |
	bag := Bag new. 
	self do: [ :each |
			bag add: each. 
			].
	^ bag sortedCounts first key = 1
\end{displaycode}
\section{A solution using the String API}
\begin{todo}
blbl
\end{todo}

\begin{displaycode}{plain}
String >> isIsogramFatestImplementation
	"'ALTRUISME' isIsogramFatestImplementation"
	1 to: self size -1 do: [ :ix |
	(self  
		findString: (self at: ix) asString
		startingAt: ix +1
		caseSensitive: false) ~~ 0 ifTrue: [ ^ false ]
	].
	^ true
\end{displaycode}
\section{A recursive approach}
Up until now we only used iterations to go from one letter to the others. In Pharo you can also define 
the computation in recursive manner. 

Before looking at a solution, imagine how you would do it. For example we could define a method that iterates over the string by removing the first element of the string and pass it as argument to an auxialliary method whose goal is to check whether the receiver includes or not the element and invoke the first method when it is necessary to continue the iteration. 

For example, the method \textcode{isIsogramRecursiveImplementation} can invoke the method \textcode{isIsogramContainCharacter:} on a subtring and the method \textcode{isIsogramContainCharacter:} can check whether its receiver contains the element and else it invokes \textcode{isIsogramRecursiveImplementation} to continue the exploration. 

\begin{displaycode}{plain}
String >> isIsogramRecursiveImplementation
	...

String >> isIsogramContainCharacter: aCharacter
	...
\end{displaycode}

Here is a possible implementation. 

\begin{displaycode}{plain}
String >> isIsogramRecursiveImplementation
	"'ALTRUISME' isIsogramRecursiveImplementation"
	"'ALTRUISMEA' isIsogramRecursiveImplementation"
	^ self isEmpty
		ifTrue: [ true ] 
		ifFalse: [ self allButFirst isIsogramContainCharacter: self first ]
\end{displaycode}

\begin{displaycode}{plain}
String >> isIsogramContainCharacter: aCharacter
	
 	^ (self includes: aCharacter) 
			ifTrue: [ false ]
			ifFalse: [ self isIsogramRecursiveImplementation ]	 
\end{displaycode}

Such solution is a solution that comes naturally when using functional languages such as Camel or Scheme. 
In Pharo it would be more adapted to data structures such as linked lists because it is cheap to get a structure representing the elements except the first one (basically on linked list is just the next element since it is also a linked list.). In the case of strings or arrays, \textcode{allButFirst} has to build a new string or array and this is costly.
\section{A low-level solution}
\begin{displaycode}{plain}
isIsogramBitImplementation
   | i |
   i := 0.
   self asLowercase do: [ :char |
         | val |
         val := (char asInteger - 96).
         (val between: 1 and: 26) ifFalse: [ ^ false ].
         (i bitAt: val ) == 1 ifTrue: [ ^ false ].
         i := (i bitAt: val put: 1).
         ].
     ^ true
\end{displaycode}

 

 

An interesting observation here is that if \#asLowercase is moved to  each character instead “val := (char asLowercase  asInteger - 96).” Then it leads to a 4-5x performance loss .
\section{Are all solutions finding the same?}
\begin{displaycode}{plain}
	| lines bits dicts  bags strings sets |
	lines := (ZnDefaultCharacterEncoder 
	  value: ZnCharacterEncoder latin1 
	  during: [
	    ZnClient new 
	      get: 'http://www.pallier.org/ressources/dicofr/liste.de.mots.francais.frgut.txt' ]) lines.

	bits := lines select: #isIsogramBitImplementation. 
	dicts := lines select: #isIsogramDictionaryImplementation. 
	bags := lines select: #isIsogramBagImplementation.
	strings := lines select: #isIsogramStringImplementation.
	sets := lines select: #isIsogramSetImplementation.
	recurs := lines select: #isIsogramRecursiveImplementation.
	{ bits . dicts .  bags . strings . sets} collect: #size. "#(23118 47674 47674 47668 47674)"
\end{displaycode}
\section{Comparing solutions}
Pharo proposes tools to measure execution speed (for example the message \textcode{timeToRun} and \textcode{millisecondsToRun:} shown below).  When an operation is too fast you cannot measure well (Check the chapter on profiling of Deep Into Pharo), so you should execute multiple times the same expressions.  

Here measuring an expression alone does not really help as you can see. 

\begin{displaycode}{plain}
['PHRAO' isIsogramSetImplementation ] timeToRun.
>>> 0
Time millisecondsToRun: ['PHRAO' isIsogramSetImplementation ] 
>>> 0
\end{displaycode}

Pharo libraries also offers the bench method that gives the number of execution possible per second. 

{[} {[} {[} 
{[}  'ALTRUISME' isIsogramSetImplementation {]} bench  '334,371 per second'

{[}  'ALTRUISME' isIsogramStringImplementation {]} bench  '546,823 per second'

{[}  'ALTRUISME' isIsogramUsingBagImplementation {]} bench  '142,432 per second'

{[}  'ALTRUISME' isIsogramDictionaryImplementation {]} bench  '147,276 per second'

{[} 'ALTRUISME' isIsogrambitImplementation {]} bench  '1,137,976 per second'

{[}  'ALTRUISME' isIsogramRecursiveImplementation {]} bench \symbol{34}'487,492 per second'\symbol{34}
{]}{]}{]}
\subsection{Some observations and comments}\label{todo explain}
\begin{itemize}
\item Size of code does not mean anything. Smaller code can be slower because they use more. 
\end{itemize}
\section{Handling french and the lesson behind}
\`{a}, \^{a}, \'{e}, \`{e}, \^{e}, \"{e}, \^{i}, \"{i}, \^{o}, \`{u}, \^{u}, \"{u}, \"{y}, \c{c}, æ et œ

\begin{displaycode}{plain}
'ALTRUISME' isIsogramSetImplementation 

'ALTRUISME' isIsogramStringImplementation 

'ALTRUISME' isIsogramUsingBagImplementation

'ALTRUISME' isIsogramDictionaryImplementation

'ALTRUISME' isIsogramBit 
\end{displaycode}
\section{So  Watch out}
You could find that it is worth to systematically use low-level messages. It is not a good strategy.
Why? They are several reasons:

\begin{itemize}
\item You may spend a lot of time to find a strong optimised solution. 
\item You may spend a lot of time optimizing a part of the system that does not need to be optimized.
\item Low-levels solutions are often more difficult to read and understand so if you need something slightly different they may break. For example what is we want to compute isogram in language where the letters are not contiguous.
\end{itemize}

\begin{important}
A good engineering practice is: Make it work, make it right, make it fast and not the inverse
\end{important}
\subsection{Variations}
\begin{displaycode}{plain}
isIsogramBit
	"['ALTRUISME' isIsogramBit] bench '337,427 per second'"

   | i |
   i := 0.
   self do: [ :char |
         | val |
         val := (char asLowercase asInteger - 96).
         (val between: 1 and: 26) ifFalse: [ ^ false ].
         (i bitAt: val ) == 1 ifTrue: [ ^ false ].
         i bitAt: val put: 1
         ].
     ^ true
\end{displaycode}

\begin{displaycode}{plain}
['ALTRUISME' isIsogramBit] bench '337,427 per second'
\end{displaycode}

What you should see is that the execution engine may also support adaptatives optimisations, i.e., depending on the program it executes it can change it on the fly to gain speed. You may wonder why it is not always the case. 
Why the compiler and execution engine (virtual machines) do not always optimise at the maximum, because optimisation takes time and space and that there is a tradeoff to reach. So virtual machines optimise aggressively code that is executed a lot because they see that it is worth doing it. 

So now we will look at other kind of words or sentences. 


% lulu requires an empty page at the end. That's why I'm using
% \backmatter here.
\backmatter

% Index would go here
\bibliographystyle{abbrv}
\bibliography{others.bib}
\end{document}
