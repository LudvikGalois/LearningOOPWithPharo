'From Squeak2.8 of 13 June 2000 [latest update: #2359] on 8 May 2001 at 8:52:38 am'!Object subclass: #LSRule	instanceVariableNames: 'leftPart rightPart '	classVariableNames: ''	poolDictionaries: ''	category: 'L-System'!LSRule class	instanceVariableNames: ''!Object subclass: #LSystem	instanceVariableNames: 'rules axiom angle '	classVariableNames: ''	poolDictionaries: ''	category: 'L-System'!LSystem class	instanceVariableNames: ''!Object subclass: #LSystemRule	instanceVariableNames: 'leftPart rightPart '	classVariableNames: ''	poolDictionaries: ''	category: 'L-System'!LSystemRule class	instanceVariableNames: ''!LSystem subclass: #LSystemSubFigures	instanceVariableNames: 'subFigures '	classVariableNames: ''	poolDictionaries: ''	category: 'L-System'!LSystemSubFigures class	instanceVariableNames: ''!TestCase subclass: #LSystemTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'L-SystemTest'!LSRule subclass: #ParametricLSRule	instanceVariableNames: 'condition '	classVariableNames: ''	poolDictionaries: ''	category: 'L-System'!ParametricLSRule class	instanceVariableNames: ''!LSystem subclass: #ParametricLSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'L-System'!ParametricLSystem class	instanceVariableNames: ''!!LSRule methodsFor: 'testing' stamp: 'SD 5/1/2001 11:49'!doesMatch: anElement 	^ (leftPart first)		= (anElement first)! !!LSRule methodsFor: 'accessing' stamp: 'SD 3/5/2001 14:09'!leftPart	^ leftPart ! !!LSRule methodsFor: 'accessing' stamp: 'SD 3/6/2001 15:46'!leftPart: left	leftPart := left! !!LSRule methodsFor: 'accessing' stamp: 'SD 3/5/2001 14:09'!rightPart	^ rightPart! !!LSRule methodsFor: 'accessing' stamp: 'SD 3/6/2001 15:46'!rightPart: right	rightPart := right! !!LSRule methodsFor: 'printing' stamp: 'SD 3/9/2001 14:05'!printOn: aStream	aStream nextPutAll: 'Rule: '.	aStream nextPutAll: leftPart asString.	aStream nextPutAll: ' -> '.	aStream nextPutAll: rightPart asString! !!LSRule methodsFor: 'comparing' stamp: 'SD 4/18/2001 15:03'!equals: aRule	"This method has to be renamed = and hashOld into hash to work and avoid to have 	twice the same rule in the L-System"		 (aRule isKindOf: self class) ifFalse: [^false].   ^ (self leftPart = aRule leftPart) and: [self rightPart = aRule rightPart] ! !!LSRule methodsFor: 'comparing' stamp: 'SD 4/18/2001 15:03'!hashOld	"hashOld into hash and equals to = to work and avoid to have 	twice the same rule in the L-System"	^ self rightPart hash bitXor: self leftPart hash! !!LSRule class methodsFor: 'instance creation' stamp: 'SD 4/29/2001 15:24'!leftPart: left rightPart: right 	^ self new 		leftPart: left; rightPart: right! !!LSRule class methodsFor: 'examples' stamp: 'SD 4/18/2001 15:04'!example	"self example inspect"	^ (LSRule leftPart: 'B' rightPart: 'A').! !!LSRule class methodsFor: 'examples' stamp: 'SD 4/18/2001 15:04'!example2	"self example2 inspect"	^ (LSRule leftPart: 'B' rightPart: 'AB').! !!LSystem methodsFor: 'rule adding' stamp: 'SD 3/24/2001 22:55'!add: aRule	self addSet: aRule! !!LSystem methodsFor: 'rule adding' stamp: 'SD 1/29/1904 05:26'!addSet: aRule	rules add: aRule! !!LSystem methodsFor: 'initialize' stamp: 'SD 3/24/2001 22:54'!initialize	self initializeSet! !!LSystem methodsFor: 'initialize' stamp: 'SD 1/29/1904 05:24'!initializeSet	rules := Set new! !!LSystem methodsFor: 'obsolete' stamp: 'SD 3/5/2001 14:29'!drawAtLevel: n		^ self drawAtLevel: n length: 5! !!LSystem methodsFor: 'obsolete' stamp: 'SD 3/5/2001 14:35'!drawAtLevel: n length: len	| turtle derivation |	turtle := TurtleWithMemory new.	derivation := (self deriveAxiomAtLevel: n).	turtle north;		interpret: derivation		length: len		angle: angle.	^ derivation! !!LSystem methodsFor: 'obsolete' stamp: 'SD 3/5/2001 14:59'!isThereARuleFor: aSymbol	^ rules keys includes: aSymbol	! !!LSystem methodsFor: 'for dict implementation' stamp: 'SD 3/6/2001 21:56'!addDict: aRule	rules at: aRule leftPart put: aRule rightPart! !!LSystem methodsFor: 'for dict implementation' stamp: 'SD 3/6/2001 21:58'!initializeDict	rules := Dictionary new! !!LSystem methodsFor: 'for dict implementation' stamp: 'SD 1/29/1904 05:27'!treatElementDict: anElement 	"returns the right part of a rule corresponding to the element (aString) passed in argument "	^ (rules keys includes: anElement asString)		ifTrue: [rules at: anElement asString]		ifFalse: [anElement asString]! !!LSystem methodsFor: 'computing' stamp: 'SD 1/29/1904 05:21'!deriveAxiomAtLevel: n 	"self new deriveAxiomAtLevel: 1"	| production |	production := axiom.	n timesRepeat: [production := self treatSequence: production].	^ production! !!LSystem methodsFor: 'computing' stamp: 'SD 3/24/2001 22:55'!treatElement: anElement 	"returns the right part of a rule corresponding to the element (aString) passed in argument "	^ self treatElementSet: anElement! !!LSystem methodsFor: 'computing' stamp: 'SD 3/24/2001 23:00'!treatElementSet: anElement 	"returns the right part of a rule corresponding to the element (aString) passed in argument "	|rule|	rule := rules detect: [:each | each doesMatch: anElement asString]		ifNone: [nil].	^rule isNil 		ifTrue: [anElement asString]		ifFalse: [rule rightPart]! !!LSystem methodsFor: 'computing' stamp: 'SD 4/18/2001 14:57'!treatSequence: aCollection	"Apply the rules to each element and return a collection that represents the result.	This version is used by the subclasses while treatString is only for the 	transformation from the turtle class implementation"	| col |	col := OrderedCollection new.	aCollection		 do: [:anElement | col addAll: (self treatElement: anElement)].	^ col! !!LSystem methodsFor: 'computing' stamp: 'SD 1/29/1904 05:03'!treatString: aString 	"Apply the rules to each element and return a string that represents the result"	| resultingString |	resultingString := ''.	aString do: [:anElement | resultingString := resultingString , (self treatElement: anElement asString)].	^ resultingString! !!LSystem methodsFor: 'accessing' stamp: 'SD 3/5/2001 14:03'!angle: aNumber 	angle := aNumber! !!LSystem methodsFor: 'accessing' stamp: 'SD 3/5/2001 14:03'!axiom: anObject	axiom := anObject! !!LSystem methodsFor: 'draw' stamp: 'SD 3/9/2001 17:25'!drawAtLevel: n angle: aNumber		^ self drawAtLevel: n length: 5 angle: aNumber! !!LSystem methodsFor: 'draw' stamp: 'SD 3/30/2001 12:24'!drawAtLevel: n length: len angle: aNumber	| turtle derivation |	turtle := TurtleWithMemory new.	derivation := (self deriveAxiomAtLevel: n).	turtle "north;"		interpret: derivation		length: len		angle: aNumber.	^ derivation! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/13/2001 16:45'!fibonacci	"self fibonacci"	| lsys |	lsys := self new axiom: 'B'.	lsys add: (LSRule leftPart: 'B' rightPart: 'A').	lsys add: (LSRule leftPart: 'A' rightPart: 'AB').	^ lsys		! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/27/2001 20:50'!hilbert   "self hilbert"   | lsys |   lsys := self new.   lsys axiom: 'L'.   lsys add: (LSRule leftPart: 'L' rightPart: '+RF-LFL-FR+').   lsys add: (LSRule leftPart: 'R' rightPart: '-LF+RFR+FL-').   ^ lsys deriveAxiomAtLevel: 2.   ! !!LSystem class methodsFor: 'examples' stamp: 'SD 1/29/1904 12:06'!islands	"self islands"	| lsys |	lsys := self new axiom: 'F+F+F+F'.	lsys add: (LSRule leftPart: 'f' rightPart: 'ffffff').	lsys add: (LSRule leftPart: 'F' rightPart: 'F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF').	World clearTurtleTrails.	lsys drawAtLevel: 2 length: 4 angle: 90.	^ lsys		! !!LSystem class methodsFor: 'examples' stamp: 'SD 1/29/1904 12:53'!islands3	"self islands3"	| lsys |	lsys := self new axiom: 'F+F+F+F'.	lsys add: (LSRule leftPart: 'f' rightPart: 'ffffff').	lsys add: (LSRule leftPart: 'F' rightPart: 'F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF').	World clearTurtleTrails.	lsys drawAtLevel: 2 length: 2 angle: 90.	^ lsys		! !!LSystem class methodsFor: 'examples' stamp: 'SD 1/29/1904 12:38'!quadraticKoch	"self quadraticKoch"	| lsys |	lsys := self new axiom: 'F-F-F-F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'F+FF-FF-F-F+F+FF-F-F+F+FF+FF-F').	World clearTurtleTrails.	lsys drawAtLevel: 2 length: 4 angle: 90.	^ lsys		! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/9/2001 17:26'!simpleBasicOne	"self simpleBasicOne"	| lsys |	World clearTurtleTrails.	lsys := self new.	lsys axiom: 'F-F-F-F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'FF-F-F-F-F-F+F'). 	lsys drawAtLevel: 4 length: 2 angle: 90.	^ lsys	! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 23:21'!simplePlant	"self simplePlant"	| lsys |	World clearTurtleTrails.	lsys := self new.	lsys axiom: 'F'.	lsys angle: 22.5.	lsys add: (LSRule leftPart: 'F' rightPart: 'FF-[-F+F+F]+[+F-F-F]'). 	lsys drawAtLevel: 4 length: 6.	^ lsys	! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/5/2001 14:33'!simplePlant4	"self simplePlant4"	| lsys |	lsys := self new.	lsys axiom: 'X'.	lsys angle: 20.	lsys add: (LSRule leftPart: 'X' rightPart: 'F[+X]F[-X]+X').	lsys add: (LSRule leftPart: 'F' rightPart: 'FF').	lsys drawAtLevel: 7 length: 3! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/5/2001 14:33'!simplePlant5	"self simplePlant5"	| lsys |	lsys := self new.	lsys axiom: 'X'.	lsys angle: 25.7.	lsys add: (LSRule leftPart: 'X' rightPart: 'F[+X][-X]FX').	lsys add: (LSRule leftPart: 'F' rightPart: 'FF').	lsys drawAtLevel: 7 length: 3! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/5/2001 14:34'!simplePlant6	"self simplePlant6"	| lsys |	lsys := self new.	lsys axiom: 'X'.	lsys angle: 22.5.	lsys add: (LSRule leftPart: 'X' rightPart: 'F-[[X]+X]+F[+FX]-X').	lsys add: (LSRule leftPart: 'F' rightPart: 'FF').	lsys drawAtLevel: 5 length: 4! !!LSystem class methodsFor: 'examples' stamp: 'SD 3/9/2001 15:44'!simplePlantTestdouble	"self simplePlantTestdouble"	| lsys |	lsys := self new.	lsys axiom: 'X'.	lsys angle: 22.5.	lsys add: (LSRule leftPart: 'X' rightPart: 'F-[[X]+X]+F[+FX]-X').	lsys add: (LSRule leftPart: 'X' rightPart: 'F-[[X]+X]+F[+FX]-X').	^ lsys! !!LSystem class methodsFor: 'instance creation' stamp: 'SD 3/5/2001 14:05'!new	^super new initialize! !!LSystemRule methodsFor: 'testing' stamp: 'SD 2/18/2001 20:57'!doesMatch: anElement 	^ (leftPart at: 1) = (anElement at: 1)! !!LSystemRule methodsFor: 'testing' stamp: 'SD 2/12/2001 16:26'!leftPart	^leftPart! !!LSystemRule methodsFor: 'testing' stamp: 'SD 2/14/2001 20:46'!rightPart	^rightPart! !!LSystemRule methodsFor: 'private' stamp: 'SD 2/14/2001 21:40'!convert: aString	"self new convert: '(A d)'"	"self new convert: '(F 1) [ + (A 1)] [- (A 1)] (F 1) (A 0)'"	^ Scanner new scanTokens: aString	! !!LSystemRule methodsFor: 'private' stamp: 'SD 2/18/2001 18:37'!setLeftPart: anElement rewritenIn: aString 		leftPart := anElement.	rightPart := (LSystemVersionThree new) decompose: aString! !!LSystemRule class methodsFor: 'instance creation' stamp: 'SD 2/11/2001 15:14'!leftPart: anElement rewrittenIn: aString 	^ self new setLeftPart: anElement rewritenIn: aString! !!LSystemSubFigures methodsFor: 'rule adding' stamp: 'SD 3/6/2001 15:33'!addSubFigure: aCharacterName withDefinition: aString 		subFigures at: aCharacterName put: aString! !!LSystemSubFigures methodsFor: 'rule adding' stamp: 'SD 4/18/2001 16:25'!subFiguresFor: aString	 	^ subFigures at:  aString							! !!LSystemSubFigures methodsFor: 'computing' stamp: 'SD 3/6/2001 15:32'!deriveAxiomAtLevel: n 	| production |	production := super deriveAxiomAtLevel: n.	^ self expandSubFiguresIn: production! !!LSystemSubFigures methodsFor: 'computing' stamp: 'SD 10/9/1933 11:09'!expandSubFiguresIn: production 	"replace all could not work"	| subFigureCharacters col|	subFigureCharacters := subFigures keys.	col := OrderedCollection new.	production do: [:each | (subFigureCharacters includes: each asString) 								ifTrue: [col addAll: (subFigures at: each asString)]								ifFalse: [col add: each ]].	^col! !!LSystemSubFigures methodsFor: 'initialize' stamp: 'SD 3/6/2001 15:31'!initialize	super initialize.	subFigures := Dictionary new! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:06'!FASS1	"self FASS1"	| lsys |	lsys := self new.	lsys axiom: '-L'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'L' rightPart: 'LF+RFR+FL-F-LFLFL-FRFR+').	lsys add: (LSRule leftPart: 'R' rightPart: '-LFLF+RFRFR+F+RF-LFL-FR').	lsys addSubFigure: 'L' withDefinition: ''.	lsys addSubFigure: 'R' withDefinition: ''.	lsys drawAtLevel: 3 length: 4! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:09'!FASS2	"self FASS2"	| lsys |	World clearTurtleTrails.	lsys := self new.	lsys axiom: '-L'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'L' rightPart: 'LFLF+RFR+FLFL-FRF-LFL-FR+F+RF-LFL-FRFRFR+').	lsys add: (LSRule leftPart: 'R' rightPart: '-LFLFLF+RFR+FL-F-LF+RFR+FLF+RFRF-LFL-FRFR').	lsys addSubFigure: 'L' withDefinition: ''.	lsys addSubFigure: 'R' withDefinition: ''.	lsys drawAtLevel: 2 length: 6! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:10'!FASS3	"self FASS3"	| lsys |	World clearTurtleTrails.	lsys := self new.	lsys axiom: '-L'.	lsys angle: 45.	lsys add: (LSRule leftPart: 'L' rightPart: 'L+F+R-F-L+F+R-F-L-F-R+F+L-F-R-F-L+F+R-F-L-F-R-F-L+F+R+F+L+F+R-F-L+F+R+F+L-F-R+F+L+F+R-F-L+F+R-F-L').	lsys add: (LSRule leftPart: 'K' rightPart: 'L+F+R-F-L+F+R-F-L-F-R+F+L-F-R-F-L+F+R-F-L-F-R-F-L+F+R+F+L+F+R-F-L+F+R+F+L-R-F+F+L+F+R-F-L+F+R-F-L').	lsys add: (LSRule leftPart: 'R' rightPart: 'R-F-L+F+R-F-L+F+R+F+L-F-R+F+L+F+R-F-L+F+R+F+L+F+R-F-L-F-R-F-L+F+R-F-L-F-R+F+L-F-R-F-L+F+R-F-L+F+R').	lsys addSubFigure: 'L' withDefinition: ''.	lsys addSubFigure: 'R' withDefinition: ''.	lsys drawAtLevel: 3 length: 2! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 3/30/2001 12:32'!allTower	"self allTower"	| lsys turtle derivation |	lsys := self new axiom: 'F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'LF+L-F-L+FL').	lsys add: (LSRule leftPart: 'L' rightPart: 'FF').	lsys addSubFigure: 'L' withDefinition: 'FF'.	World clearTurtleTrails.	turtle := TurtleWithMemory new.	turtle west; jumpAt: 200@300.	turtle east.	derivation := (lsys deriveAxiomAtLevel: 0).	turtle		interpret: derivation		length: 2		angle: 90.	turtle jump: 20.	turtle east.	derivation := (lsys deriveAxiomAtLevel: 1).	turtle		interpret: derivation		length: 2		angle: 90.	turtle east; jump: 20.	derivation := (lsys deriveAxiomAtLevel: 2).	turtle		interpret: derivation		length: 2		angle: 90.	derivation := (lsys deriveAxiomAtLevel: 3).	turtle east; jump: 40.	turtle		interpret: derivation		length: 2		angle: 90.	derivation := (lsys deriveAxiomAtLevel: 4).	turtle  jumpAt: 200@200.	turtle east.	turtle		interpret: derivation		length: 1		angle: 90.! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 3/24/2001 22:57'!dragonCurve	"self dragonCurve"	| lsys |	lsys := self new.	lsys axiom: 'L'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'L' rightPart: 'L+R+').	lsys add: (LSRule leftPart: 'R' rightPart: '-L-R').	lsys addSubFigure: 'L' withDefinition: 'F'.	lsys addSubFigure: 'R' withDefinition: 'F'.	World  clearTurtleTrails.	lsys drawAtLevel: 10 length: 6! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:12'!hexagonalGosperCurve	"self hexagonalGosperCurve"	"bugge at level 4 pretty hard to find"	| lsys |	lsys := self new.	lsys axiom: 'L'.	lsys angle: 60.	lsys add: (LSRule leftPart: 'L' rightPart: 'L+R++R-L--LL-R+').	lsys add: (LSRule leftPart: 'K' rightPart: '-L+RR++R+L--L-R').	lsys addSubFigure: 'L' withDefinition: 'F'.	lsys addSubFigure: 'R' withDefinition: 'F'.	lsys drawAtLevel: 4 length: 6! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 10/9/1933 11:05'!hilbert   "self hilbert"   | lsys |   lsys := self new.   lsys axiom: 'L'.   lsys add: (LSRule leftPart: 'L' rightPart: '+RF-LFL-FR+').   lsys add: (LSRule leftPart: 'R' rightPart: '-LF+RFR+FL-').   lsys addSubFigure: 'L' withDefinition: '+F-F-F+'.   lsys addSubFigure: 'R' withDefinition: '-F+F+F-'.   lsys drawAtLevel: 3 length: 4 angle: 90.   ^ lsys! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:14'!peano	"self peano"	| lsys |	World clearTurtleTrails.	lsys := self new.	lsys axiom: 'L'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'L' rightPart: 'LFRFL-F-RFLFR+F+LFRFL').	lsys add: (LSRule leftPart: 'R' rightPart: 'RFLFR+F+LFRFL-F-RFLFR').	lsys addSubFigure: 'L' withDefinition: 'F'.	lsys addSubFigure: 'R' withDefinition: 'F'.	lsys drawAtLevel: 3 length: 5! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:15'!peano2	"self peano2"	| lsys |	lsys := self new.	lsys axiom: 'L'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'L' rightPart: 'LFRFL-F-RFLFR+F+LFRFL').	lsys add: (LSRule leftPart: 'R' rightPart: 'RFLFR+F+LFRFL-F-RFLFR').	lsys addSubFigure: 'L' withDefinition: ''.	lsys addSubFigure: 'R' withDefinition: ''.	lsys drawAtLevel: 3 length: 5! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:16'!peanoCurve	"self peanoCurve"	| lsys |	World clearTurtleTrails.	lsys := self new.	lsys axiom: 'S'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'S' rightPart: 'SFZFS+F+ZFSFZ-F-SFZFS').	lsys add: (LSRule leftPart:  'Z' rightPart: 'FSFZ-F-SFZFS+F+ZFSFZ').	lsys addSubFigure: 'S' withDefinition: 'F+F+F-F-F'.	lsys addSubFigure: 'Z' withDefinition: 'F-F-F+F+F'.	lsys drawAtLevel: 1 length: 10! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:17'!quadraticGosperCurve	"self quadraticGosperCurve"	| lsys |	lsys := self new.	lsys axiom: '-R'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'L' rightPart: 'LL-R-R+L+L-R-RL+R+LLR-L+R+LL+R-LR-R-L+L+RR-').	lsys add: (LSRule leftPart: 'R' rightPart: '+LL-R-R+L+LR+L-RR-L-R+LRR-L-RL+L+R-R-L+L+RR').	lsys addSubFigure: 'L' withDefinition: 'F'.	lsys addSubFigure: 'R' withDefinition: 'F'.	lsys drawAtLevel: 2 length: 6! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:06'!sierpinski	"self sierpinski"	| lsys |	lsys := self new.	lsys axiom: 'R'.	lsys angle: 60.	lsys add: (LSRule leftPart: 'L' rightPart: 'R+L+R').	lsys add: (LSRule leftPart: 'R' rightPart: 'L-R-L').	lsys addSubFigure: 'L' withDefinition: 'F'.	lsys addSubFigure: 'R' withDefinition: 'F'.	World  clearTurtleTrails.	lsys drawAtLevel: 7 length: 2! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 4/18/2001 16:07'!sierpinski91	"self sierpinski91"	| lsys |	lsys := self new.	lsys axiom: 'R'.	lsys add: (LSRule leftPart: 'L' rightPart: 'R+L+R').	lsys add: (LSRule leftPart: 'R' rightPart: 'L-R-L').	lsys addSubFigure: 'L' withDefinition: 'F'.	lsys addSubFigure: 'R' withDefinition: 'F'.	World  clearTurtleTrails.	lsys drawAtLevel: 8 length: 2 angle: 60! !!LSystemSubFigures class methodsFor: 'examples' stamp: 'SD 3/30/2001 12:24'!tower	"self tower"	| lsys |	lsys := self new axiom: 'F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'LF+L-F-L+FL').	lsys add: (LSRule leftPart: 'L' rightPart: 'FF').	lsys addSubFigure: 'L' withDefinition: 'FF'.	World clearTurtleTrails.	lsys drawAtLevel: 2 length: 2 angle: 90.	^ lsys! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 21:49'!testDefaultConditionBlock	"(self selector: #testDefaultConditionBlock) debug"	| rule |	rule := ParametricLSRule leftPart: '(F d)' rightPart: '(F d - 1)'.	self assert: (rule condition value: #nothing)! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 16:47'!testEvaluate	"(self selector: #testEvaluate) debug"	self assert: (ParametricLSystem new evaluate: #(A 2 * 3)) =  #(#A 6).	self assert: (ParametricLSystem new evaluate: #(A 2 - 3)) =  #(#A -1).		self assert: (ParametricLSystem new evaluate: #(A 2 + 3)) =  #(#A 5).		! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 21:49'!testPartConversion	"(self selector: #testPartConversion) debug"	| rule |	rule := ParametricLSRule leftPart: '(F d)' rightPart: '(F d - 1)'.	self assert: rule leftPart = #(F d).	self assert: rule rightPart = #((F d - 1)).! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 21:49'!testRuleMatchingElement	"(self selector: #testRuleMatchingElement) debug"	| rule |	rule := ParametricLSRule leftPart: '(F d)' rightPart: '(F d - 1)'.	self assert: (rule doesMatch: #(F 1))! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 21:48'!testRuleMatchingElementWithBlock	"(self selector: #testRuleMatchingElementWithBlock) debug"	| rule |	rule := ParametricLSRule leftPart: '(F d)' rightPart: '(F d - 1)' condition: [:each| (each at: 2) > 0].	self assert: (rule doesMatch: #(F 1)).	self deny: (rule doesMatch: #(F -1)).! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/29/2001 22:58'!testShouldBeEvaluated	"(self selector: #testShouldBeEvaluated) debug"	self assert: (ParametricLSystem new shouldBeEvaluated: #(#A 2 #* 3 )).		self deny:(ParametricLSystem new shouldBeEvaluated: #(#A d #* 3 )).	! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 17:05'!testSubstitute	"(self selector: #testSubstitute) debug"		self assert:  (ParametricLSystem new substitute: #d by: 1 in: #((A d) d)) =  #(#(#A 1) 1).	self assert:  (ParametricLSystem new substitute: #d by: 1 in: #((A d * 2) d)) =  #(#(#A 2) 1).	self assert:  (ParametricLSystem new substitute: #d by: 1 in:  #((A d) (A 0) (A 1 * 3) d)) =  #(#(#A 1) #(#A 0) #(#A 3) 1).	! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 4/18/2001 21:49'!testTreatParametricElement	"(self selector: #testTreatParametricElement) debug"	| lsys rule1 |	lsys := ParametricLSystem new.	lsys axiom: '(A 100)'.	lsys angle: 88.	rule1 := ParametricLSRule 				leftPart: '(A d)' 				rightPart: '(F d)[+(A d / 1.456)][-(A d / 1.456)]'.	lsys add: rule1.	self assert: (lsys treatElement: #+) = #(#+).	self assert: (lsys treatElement: #(F 2)) = #(#(#F 2)).	self assert: (lsys treatElement: #(A 2)) asString = '#(#(#F 2) #[ #+ #(#A 1.373626373626374) #] #[ #- #(#A 1.373626373626374) #])'.		! !!LSystemTest methodsFor: 'testing parametric ' stamp: 'SD 5/1/2001 11:02'!testTreatParametricSequence	"(self selector: #testTreatParametricSequence) debug"	| lsys rule1 |	lsys := ParametricLSystem new.	lsys axiom: '(A 100)'.	lsys angle: 88.	rule1 := ParametricLSRule leftPart: '(A d)' rightPart: '(F d)[+(A d / 1.456)][-(A d / 1.456)]'.	lsys add: rule1.	self assert: (lsys treatSequence: #(#+ )) asArray = #(#+ ).	self assert: (lsys treatSequence: #(#(#F 2) )) asArray = #(#(#F 2) ).	self assert: (lsys treatSequence: #(#+ #[ #(#F 2))) asArray = #(#+ #[ #(#F 2)).	self assert: (lsys treatSequence: #(#+ #(#A 2) #- )) asString = 'an OrderedCollection(#+ #(#F 2) #[ #+ #(#A 1.373626373626374) #] #[ #- #(#A 1.373626373626374) #] #-)'! !!LSystemTest methodsFor: 'testing LSystemWithSubFigures' stamp: 'SD 4/18/2001 16:28'!testExpand	"(self selector: #testExpand) debug"	| lsys |	lsys := LSystemSubFigures new.	lsys axiom: 'S'.	lsys angle: 90.	lsys add: (LSRule leftPart: 'S' rightPart: 'SFZFS+F+ZFSFZ-F-SFZFS').	lsys add: (LSRule leftPart:  'Z' rightPart: 'FSFZ-F-SFZFS+F+ZFSFZ').	lsys addSubFigure: 'S' withDefinition: 'F+F+F-F-F'.	lsys addSubFigure: 'Z' withDefinition: 'F-F-F+F+F'.	self assert: (lsys subFiguresFor: 'S') = 'F+F+F-F-F'.	self assert: (lsys subFiguresFor: 'Z') = 'F-F-F+F+F'.	self assert: (lsys  deriveAxiomAtLevel: 1) asString= 'an OrderedCollection($F $+ $F $+ $F $- $F $- $F $F $F $- $F $- $F $+ $F $+ $F $F $F $+ $F $+ $F $- $F $- $F $+ $F $+ $F $- $F $- $F $+ $F $+ $F $F $F $+ $F $+ $F $- $F $- $F $F $F $- $F $- $F $+ $F $+ $F $- $F $- $F $+ $F $+ $F $- $F $- $F $F $F $- $F $- $F $+ $F $+ $F $F $F $+ $F $+ $F $- $F $- $F)'	! !!LSystemTest methodsFor: 'testing LSystem' stamp: 'SD 4/18/2001 16:05'!testDeriveAxiom	"(self selector: #testDeriveAxiom) debug"	|lsys |	lsys := LSystem new.	lsys axiom: 'F-F-F-F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'FF-F-F-F-F-F+F').	lsys add: (LSRule leftPart: 'G' rightPart: 'GG-G-F-F-F-F+F').	self assert: (lsys deriveAxiomAtLevel: 0) =  'F-F-F-F'.	self assert: (lsys deriveAxiomAtLevel: 1) asString = 'an OrderedCollection($F $F $- $F $- $F $- $F $- $F $- $F $+ $F $- $F $F $- $F $- $F $- $F $- $F $- $F $+ $F $- $F $F $- $F $- $F $- $F $- $F $- $F $+ $F $- $F $F $- $F $- $F $- $F $- $F $- $F $+ $F)'	! !!LSystemTest methodsFor: 'testing LSystem' stamp: 'SD 4/18/2001 15:38'!testTreatElement	"(self selector: #testTreatElement) debug"	|lsys |	lsys := LSystem new.	lsys axiom: 'F-F-F-F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'FF-F-F-F-F-F+F').	lsys add: (LSRule leftPart: 'G' rightPart: 'GG-G-F-F-F-F+F').	self assert: (lsys treatElement: 'F') = 'FF-F-F-F-F-F+F'.	"only treat the first character"	self assert: (lsys treatElement: 'FF') = 'FF-F-F-F-F-F+F'.	self assert: (lsys treatElement: 'A') = 'A'.	self assert: (lsys treatElement: 'G') = 'GG-G-F-F-F-F+F'.		! !!LSystemTest methodsFor: 'testing LSystem' stamp: 'SD 4/18/2001 15:39'!testTreatSequence	"(self selector: #testTreatSequence) debug"	|lsys |	lsys := LSystem new.	lsys axiom: 'F-F-F-F'.	lsys add: (LSRule leftPart: 'F' rightPart: 'FF-F-F-F-F-F+F').	lsys add: (LSRule leftPart: 'G' rightPart: 'GG-G-F-F-F-F+F').	self assert: (lsys treatSequence: '') asString = 'an OrderedCollection()'.	"only treat the first character"	self assert: (lsys treatSequence: 'FZZF') asString = 'an OrderedCollection($F $F $- $F $- $F $- $F $- $F $- $F $+ $F $Z $Z $F $F $- $F $- $F $- $F $- $F $- $F $+ $F)'.	self assert: (lsys treatSequence: 'A') asString =  'an OrderedCollection($A)'.	self assert: (lsys treatSequence: 'FG') asString =  'an OrderedCollection($F $F $- $F $- $F $- $F $- $F $- $F $+ $F $G $G $- $G $- $F $- $F $- $F $- $F $+ $F)'.		! !!ParametricLSRule methodsFor: 'testing' stamp: 'SD 3/6/2001 09:43'!doesMatch: anElement
	
		^ (super doesMatch: anElement)
				and: [condition value: anElement]! !!ParametricLSRule methodsFor: 'accessing' stamp: 'SD 3/6/2001 09:42'!condition 
		^ condition! !!ParametricLSRule methodsFor: 'accessing' stamp: 'SD 3/6/2001 09:42'!condition: aBlock

		condition := aBlock! !!ParametricLSRule methodsFor: 'accessing' stamp: 'SD 5/1/2001 11:49'!leftPart: left 	leftPart := (self convertToArray: left)				first! !!ParametricLSRule methodsFor: 'accessing' stamp: 'SD 4/18/2001 21:31'!rightPart: right	rightPart := self convertToArray: right! !!ParametricLSRule methodsFor: 'private' stamp: 'SD 3/6/2001 15:46'!convertToArray: anElement	^ Scanner new scanTokens: anElement	! !!ParametricLSRule class methodsFor: 'instance creation' stamp: 'SD 3/6/2001 09:44'!leftPart: left rightPart: right 	^ self leftPart: left rightPart: right condition: [:each | true]! !!ParametricLSRule class methodsFor: 'instance creation' stamp: 'SD 3/6/2001 09:46'!leftPart: left rightPart: right condition: aBlock

		^ (super leftPart: left rightPart: right) condition: aBlock! !!ParametricLSystem methodsFor: 'draw' stamp: 'SD 3/5/2001 14:53'!drawAtLevel: n	| turtle derivation |	turtle := TurtleWithMemory new.	derivation := (self deriveAxiomAtLevel: n).	turtle north;		interpretExpressions: derivation		angle: angle.	^ derivation! !!ParametricLSystem methodsFor: 'draw' stamp: 'SD 5/7/2001 22:37'!drawAtLevel: n magnified: times 	| turtle derivation |	turtle := TurtleWithMemory new.	derivation := self deriveAxiomAtLevel: n.	turtle 		interpretExpressions: derivation		angle: angle		magnified: times.	^ derivation! !!ParametricLSystem methodsFor: 'computing' stamp: 'SD 5/1/2001 11:47'!evaluate: anElement 	"self new evaluate: #(A 2 * 3) -> #(#A 6)"	"self new evaluate: #(A 2 - 3) -> #(#A -1)"	"self new evaluate: #(A 2 + 3) -> #(#A 5)"	| op1 op2 oper |	op1 := anElement second.	oper := anElement third.	op2 := anElement fourth.	^ Array with: (anElement first)		with: (op1 perform: oper with: op2)! !!ParametricLSystem methodsFor: 'computing' stamp: 'SD 4/29/2001 22:50'!isFragment: anElement	^ anElement class = Array! !!ParametricLSystem methodsFor: 'computing' stamp: 'SD 4/29/2001 23:00'!shouldBeEvaluated: aFragment 	^ aFragment size = 4		and: [aFragment second isNumber and: [(aFragment fourth) isNumber]]! !!ParametricLSystem methodsFor: 'computing' stamp: 'SD 4/29/2001 22:55'!substitute: element by: value in: aCollection 	"self new substitute: #d by: 1 in: #((A d) d)  	-> #(#(#A 1) 1)"	"self new substitute: #d by: 1 in: #((A d * 2) d)  	-> #(#(#A 2) 1)"	"self new substitute: #d by: 1 in: #((A d) (A 0) (A 1 * 3) d)  	-> #(#(#A 1) #(#A 0) #(#A 3) 1)"	^ aCollection		collect: [:each | (self isFragment: each)				ifTrue: 					[| res | 					res := self								substitute: element								by: value								in: each.					(self shouldBeEvaluated: res)						ifTrue: [self evaluate: res]						ifFalse: [res]]				ifFalse: [each = element						ifTrue: [value]						ifFalse: [each]]]! !!ParametricLSystem methodsFor: 'computing' stamp: 'SD 5/1/2001 11:45'!treatElement: anElement 	"returns an array containing an Element if anElement is a single  	symbol or if anElement is not a left part of a rule, else returns an  	array representing the  	right part of a rule"	| selectedRule |	(self isFragment: anElement)		ifFalse: [^ Array with: anElement].	selectedRule := rules detect: [:each | each doesMatch: anElement]				ifNone: [].	^ selectedRule isNil		ifTrue: [Array with: anElement]		ifFalse: [self				substitute: (selectedRule leftPart second)				by: (anElement second)				in: selectedRule rightPart]! !!ParametricLSystem methodsFor: 'computing' stamp: 'SD 3/24/2001 22:54'!treatElementDict: anElement 	"returns an array containing an Element if anElement is a single symbol	or if anElement is not a left part of a rule, else returns an array representing the 	right part of a rule"		| firstSymbol selectedRule |	(anElement class = Array) ifFalse: [^ Array with: anElement].	firstSymbol := (anElement at: 1).	^ (self isThereARuleFor: firstSymbol)		ifFalse: [Array with: anElement]		ifTrue: [selectedRule := (rules at: firstSymbol) 									detect: [:each | each doesMatch: anElement]									ifNone: [self error: 'error no matching rule'].		self substitute: (selectedRule leftPart at: 2) 					     by: (anElement at: 2)  			in: selectedRule rightPart]		! !!ParametricLSystem methodsFor: 'rule adding' stamp: 'SD 3/24/2001 22:54'!addDict: aRule 	| ruleForElement |	ruleForElement := rules 						at: ((aRule leftPart) at: 1) 						ifAbsentPut: [OrderedCollection new].	ruleForElement add: aRule! !!ParametricLSystem methodsFor: 'rule adding' stamp: 'SD 3/24/2001 22:58'!addSet: aRule 	rules add: aRule! !!ParametricLSystem methodsFor: 'private' stamp: 'SD 3/5/2001 18:06'!convertToArray: anElement	^ Scanner new scanTokens: anElement! !!ParametricLSystem methodsFor: 'accessing' stamp: 'SD 4/18/2001 21:29'!axiom: anElement		axiom := (self convertToArray: anElement)! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/7/2001 21:39'!Leaf1p129a	"self Leaf1p129a"	| lsys rule1 rule2 rule3 |	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 45.	rule1 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(A d - 1)'				condition: [:each | each second > 0].	rule2 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(F 2)[+(A 1)][-(A 1)](F 2)(A 0)'				condition: [:each | each second = 0].	rule3 := ParametricLSRule leftPart: '(F d)' rightPart: '(F d * 1.33)'.	lsys add: rule1.	lsys add: rule2.	lsys add: rule3.	^ lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 15:55'!drawExamplep129a	"self drawExamplep129a"	World clearTurtleTrails.	^self examplep129a drawAtLevel: 6 magnified: 1.	 ! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/8/2001 08:45'!drawExamplep129b	"self drawExamplep129b"	World clearTurtleTrails.	^ self examplep129b drawAtLevel: 10 magnified: 1! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/8/2001 08:46'!drawExamplep129c	"self drawExamplep129c"	World clearTurtleTrails.	^ self examplep129c drawAtLevel: 16 magnified: 0.8! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 11:08'!drawExamplep130	"self drawExamplep130"	World clearTurtleTrails.	^self examplep130 drawAtLevel: 20 magnified: 1.! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 11:10'!drawExamplep180	"self drawExamplep180"	World clearTurtleTrails.	^self examplep180 drawAtLevel: 8 magnified: 1.2.	 	! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/24/2001 23:50'!drawExamplep47	"self drawExamplep47"	World clearTurtleTrails.	^self examplep47 drawAtLevel: 3 magnified: 100.	 	! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 15:17'!drawExamplep47a	"self drawExamplep47a"	World clearTurtleTrails.	^self examplep47a drawAtLevel: 4 magnified: 200.	 ! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 15:19'!drawExamplep49	"self drawExamplep49"	World clearTurtleTrails.	^self examplep49 drawAtLevel: 8 magnified: 1.	 	! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/6/2001 15:26'!drawExamplep50	"self drawExamplep50"	World clearTurtleTrails.	^self examplep50 drawAtLevel: 12 magnified: 3.	 ! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 3/5/2001 22:48'!drawExamplep50test	"self drawExamplep50test"	World clearTurtleTrails.	^self examplep50 drawAtLevel: 10 magnified: 5.	 ! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/7/2001 21:40'!drawLeaf1p129a	"self drawLeaf1p129a"	World clearTurtleTrails.	^ self Leaf1p129a drawAtLevel: 10 magnified: 1! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/14/2001 16:20'!drawTgrowings	"self drawTgrowings"	|lsys turtle|	World clearTurtleTrails.	lsys := self examplep50.	turtle := TurtleWithMemory new.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 1)						angle: 88 magnified: 5.	turtle := TurtleWithMemory new.	turtle east; jump: 10 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 2)						angle: 88 magnified: 5.	turtle := TurtleWithMemory new.	turtle east; jump: 30 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 3)						angle: 88 magnified: 5.	turtle := TurtleWithMemory new.	turtle east; jump: 60 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 4)						angle: 88 magnified: 5.	turtle := TurtleWithMemory new.	turtle east; jump: 100 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 5)						angle: 88 magnified: 5.	turtle := TurtleWithMemory new.	turtle east; jump: 170 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 6)						angle: 88 magnified: 5.	turtle := TurtleWithMemory new.	turtle east; jump: 280 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 7)						angle: 88 magnified: 5.		 ! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/14/2001 16:43'!drawTgrowings2	"self drawTgrowings2"	|lsys turtle|	World clearTurtleTrails.	lsys := self examplep49.	turtle := TurtleWithMemory new.	turtle west; jump: 400; north; interpretExpressions: (lsys deriveAxiomAtLevel: 1)						angle: 88.	turtle := TurtleWithMemory new.	turtle west; jump: 370 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 2)						angle: 88.	turtle := TurtleWithMemory new.	turtle west; jump: 310 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 3)						angle: 88.	turtle := TurtleWithMemory new.	turtle west; jump: 230 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 4)						angle: 88.	turtle := TurtleWithMemory new.		turtle west; jump: 140 ; north; interpretExpressions: (lsys deriveAxiomAtLevel: 5)						angle: 88 .	turtle := TurtleWithMemory new.	turtle west; jump: 40 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 6)						angle: 88.	turtle := TurtleWithMemory new.	turtle east; jump: 60 ; north.	turtle north; interpretExpressions: (lsys deriveAxiomAtLevel: 7)						angle: 88 .		 ! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:48'!examplep129a	"self examplep129a"	| lsys rule1 rule2 rule3 |	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 45.	rule1 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(A d - 1)'				condition: [:each | (each at: 2) > 0].	rule2 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(F 2)[+(A 0)][-(A 0)](F 2)(A 0)'				condition: [:each | (each at: 2)						= 0].	rule3 := ParametricLSRule 				leftPart: '(F d)' 				rightPart: '(F d * 1.8)'.	lsys add: rule1.	lsys add: rule2.	lsys add: rule3.	^ lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/8/2001 08:44'!examplep129b	"self examplep129b"	| lsys rule1 rule2 rule3 |	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 45.	rule1 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(A d - 1)'				condition: [:each | each second > 0].	rule2 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(F 1)[+(A 1)][-(A 1)](F 1)(A 0)'				condition: [:each | each second = 0].	rule3 := ParametricLSRule leftPart: '(F d)' rightPart: '(F d * 1.5)'.	lsys add: rule1.	lsys add: rule2.	lsys add: rule3.	^ lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/8/2001 08:46'!examplep129c	"self examplep129c"	| lsys rule1 rule2 rule3 |	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 45.	rule1 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(A d - 1)'				condition: [:each | each second > 0].	rule2 := ParametricLSRule				leftPart: '(A d)'				rightPart: '(F 1)[+(A 2)][-(A 2)](F 1)(A 0)'				condition: [:each | each second = 0].	rule3 := ParametricLSRule leftPart: '(F d)' rightPart: '(F d * 1.36)'.	lsys add: rule1.	lsys add: rule2.	lsys add: rule3.	^ lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:48'!examplep130	"self examplep130"	| lsys rule1 rule2 rule3 rule4 rule5|	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 45.	rule1 := ParametricLSRule 				leftPart: '(A d)' 				rightPart: '(A d - 1)'				condition: [:each | (each at: 2) > 0 ].	rule2 := ParametricLSRule 				leftPart: '(A d)' 				rightPart: '(F1)[+(A1)](F1)(B0)'				condition: [:each | (each at: 2)  = 0 ].	rule3 := ParametricLSRule 				leftPart: '(B d)' 				rightPart: '(B d - 1)'				condition: [:each | (each at: 2)  > 0 ].	rule4 := ParametricLSRule 				leftPart: '(B d)' 				rightPart: '(F 1)[-(B 1)](F 1)(A 0)'				condition: [:each | (each at: 2) = 0 ].	rule5 := ParametricLSRule 				leftPart: '(F d)' 				rightPart: '(Fd * 1.26)'.	lsys add: rule1.	lsys add: rule2.	lsys add: rule3.	lsys add: rule4.	lsys add: rule5.	^lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:48'!examplep180	"self examplep180"	| lsys rule1 rule2  |	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 45.	rule1 := ParametricLSRule 				leftPart: '(A d)' 				rightPart: '(F 2)[+(A 0)][-(A 0)](F 2)(A 0)'.	rule2 := ParametricLSRule 				leftPart: '(F d)' 				rightPart: '(F d * 1.452)'.	lsys add: rule1.	lsys add: rule2.	^lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:48'!examplep47	"self examplep47"	"self drawExamplep47"	| lsys rule1  |	lsys := self new.	lsys axiom: '(F 1)'.	lsys angle: 86.	rule1 := ParametricLSRule 				leftPart: '(F x)' 				rightPart: '(F x * 0.3) + (F x * 0.4582) - - (F x * 0.4582) + (F x * 0.7)'.	lsys add: rule1.	^lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:48'!examplep47a	"self examplep47a"	"self drawExamplep47a"	| lsys rule1  |	lsys := self new.	lsys axiom: '(F 1)'.	lsys angle: 81.	rule1 := ParametricLSRule 				leftPart: '(F x)' 				rightPart: '(F x * 0.3) + (F x * 0.4582) - - (F x * 0.4582) + (F x * 0.7)'.	lsys add: rule1.	^lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:47'!examplep48	"self examplep48"	| lsys rule1  |	lsys := self new.	lsys axiom: '(A 1)'.	lsys angle: 86.	rule1 := ParametricLSRule 				leftPart: '(A s)' 				rightPart: '(F s)[+(A s / 1.456)][- (A s / 1.456)]'.	lsys add: rule1.	^lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 5/7/2001 22:22'!examplep49	"self examplep49"	| lsys rule1 |	lsys := self new.	lsys axiom: '(A 60)'.	lsys angle: 88.	rule1 := ParametricLSRule leftPart: '(A d)' rightPart: '(F d)[+(A d / 1.456)][-(A d / 1.456)]'.	lsys add: rule1.	^ lsys! !!ParametricLSystem class methodsFor: 'examples' stamp: 'SD 4/18/2001 21:48'!examplep50	"self examplep50"	| lsys rule1 rule2  |	lsys := self new.	lsys axiom: '(A 0)'.	lsys angle: 88.	rule1 := ParametricLSRule 				leftPart: '(A d)' 				rightPart: '(F 1)[+(A 0)][-(A 0)]'.	rule2 := ParametricLSRule 				leftPart: '(F d)' 				rightPart: '(F d * 1.456)'.	lsys add: rule1.	lsys add: rule2.	^lsys! !!TurtleWithMemory methodsFor: 'L-system' stamp: 'SD 5/7/2001 22:42'!interpretExpression: anExpression angle: degree magnified: times 	| aCharacter |	(anExpression isKindOf: Array)		ifTrue: [aCharacter := anExpression first]		ifFalse: [aCharacter := anExpression].	aCharacter = #F		ifTrue: [self go: anExpression second					* times]		ifFalse: [aCharacter = #+				ifTrue: [self turnLeft: degree]				ifFalse: [aCharacter = #-						ifTrue: [self turnRight: degree]						ifFalse: [aCharacter = #[								ifTrue: [self pushCurrentState]								ifFalse: [aCharacter = #] ifTrue: [self restoreState]]]]]! !