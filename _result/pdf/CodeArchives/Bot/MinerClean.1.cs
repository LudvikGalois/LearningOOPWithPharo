'From Squeak3.6 of ''6 October 2003'' [latest update: #5424] on 20 November 2003 at 10:21:41 am'!"Change Set:		MinerDate:			23 December 2002Author:			stephane ducasseA small environment with robots.Version with no bordering bricks.MinerWorldBoard newStandAlone openInWorldMinerWorldBoardEditor newStandAlone openInWorldVersion with 	- removed isKindOf:	- test case	- fixed bug in relative sensors	- fixed the bugs with drag and drop	- revised the interface to have shorter names.	- fixed robot variables protocol	- renamed diamNumber:	- introduce sounds	- fixed bug with diamonds on top 	was blocking tests	- fixed bugs with editor dropping diamonds	- paint + fixed bug	- isOnBlue	- introduce magenta brick	- fix isOnMagenta	- added randomDirection	- added method comments + remove empty categories"!Morph subclass: #Miner	instanceVariableNames: 'botWorldPosition direction botWorld name diamNumber vars '	classVariableNames: 'BumpSoundOn DropSoundOn MotorSoundOn PickSoundOn '	poolDictionaries: ''	category: 'Joe The Miner'!Miner class	instanceVariableNames: 'botCounter colorIndex colorTable '!SystemWindow subclass: #MinerSystemWindow	instanceVariableNames: 'botWorldBoard '	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!!MinerSystemWindow commentStamp: 'sd 12/24/2002 09:07' prior: 0!This class defines a specific kind of system window that knows the botWorldBoard for which it is issued. Note the direct reference to botWorldBoard is not the best design but events where insufficient.!TestCase subclass: #MinerTest	instanceVariableNames: 'world bot '	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!Workspace subclass: #MinerWorkspace	instanceVariableNames: 'botWorldBoard '	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!BorderedMorph subclass: #MinerWorld	instanceVariableNames: 'area bots areas areaIndex editing currentSymbol '	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!!MinerWorld commentStamp: 'sd 12/17/2002 11:16' prior: 0!MinerWorld newStandAlone openInWorld!MinerWorld class	instanceVariableNames: 'tileDescriptions defaultTileSize '!BorderedMorph subclass: #MinerWorldBoard	instanceVariableNames: 'botWorld botControllers '	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!!MinerWorldBoard commentStamp: 'sd 12/23/2002 13:09' prior: 0!MinerWorldBoard newStandAlone openInWorld!MinerWorldBoard subclass: #MinerWorldBoardEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!BorderedMorph subclass: #MinerWorldTile	instanceVariableNames: 'botWorldPosition botWorld '	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldBlackTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldBrick	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldDiamond	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldGreenTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldGroundTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldMagentaTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldStartTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!BorderedMorph subclass: #MinerWorldTilePane	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!MinerWorldTile subclass: #MinerWorldYellowTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe The Miner'!!Miner methodsFor: 'accessing' stamp: 'sd 12/24/2002 21:06'!botWorld	^ botWorld ! !!Miner methodsFor: 'accessing' stamp: 'sd 12/20/2002 17:02'!botWorld: aMinerWorld	botWorld := aMinerWorld! !!Miner methodsFor: 'accessing' stamp: 'sd 2/3/2002 21:24'!botWorldPosition 	^ botWorldPosition ! !!Miner methodsFor: 'accessing' stamp: 'sd 2/4/2002 16:13'!botWorldPosition: aPoint	botWorldPosition := aPoint. ! !!Miner methodsFor: 'accessing' stamp: 'sd 2/11/2002 21:59'!diamNumber	^ diamNumber! !!Miner methodsFor: 'accessing' stamp: 'sd 2/3/2002 21:38'!direction	^ direction! !!Miner methodsFor: 'accessing' stamp: 'sd 2/4/2002 22:07'!direction: aPoint	direction := aPoint.	self changed! !!Miner methodsFor: 'accessing' stamp: 'sd 2/10/2002 12:59'!name	^ name! !!Miner methodsFor: 'accessing' stamp: 'sd 2/10/2002 12:59'!name: aString	name := aString! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/1/2003 08:46'!canDrop	"return true if the receiver has still a diamond to drop"		^ diamNumber > 0! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/1/2003 08:46'!canPick		^ botWorld isDiamondAt: botWorldPosition! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/4/2003 11:50'!decreaseDiamondNumber		self loadDiams: self diamNumber - 1! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/4/2003 21:14'!drop	"drop a diamond on the current position if carrying a diamond"		self canDrop		ifTrue: [self dropSound.			self decreaseDiamondNumber.			botWorld addDiamondAt: botWorldPosition.			botWorld botsUpFront]		ifFalse: [self bumpSound. self error: self name printString , ' does not have diamond to drop']! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/4/2003 11:50'!increaseDiamondNumber		self loadDiams: self diamNumber + 1! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/5/2003 10:11'!loadDiams: anInteger 		diamNumber := anInteger.	self triggerEvent: #diamNumber:! !!Miner methodsFor: 'diamonds' stamp: 'sd 4/4/2003 21:14'!pick	"pick a diamond if possible, else raise an error"		self canPick		ifTrue: [self pickSound.			self increaseDiamondNumber.			botWorld removeDiamondAt: botWorldPosition]		ifFalse: [self bumpSound. self error: 'Alert is no diamond to pick up!!']! !!Miner methodsFor: 'drawing' stamp: 'sd 12/26/2002 12:39'!drawOn1: aCanvas 	"self new openInWorld"	|   point h pointEye h2 head |	h := self height //3.	h2 := self height //5.	point :=  (self direction x * h)@(self direction y * h).	pointEye := (self direction x * 2)@(self direction y * 2).	2 to: 10 do: [:i | 					aCanvas 						fillOval: (self bounds topLeft + i										extent: self height - 6 - (i *2))						color: (Color 									r: i * 0.1 * color red									g: i * 0.1 * color green 									b: i * 0.1 * color blue)].	head := (Rectangle center: (self bounds center + point) extent: h).	aCanvas		fillOval: head		color: Color yellow darker.	aCanvas		fillOval: (Rectangle center: (head center + pointEye) extent: h2)		color: Color black.! !!Miner methodsFor: 'drawing' stamp: 'sd 12/26/2002 12:43'!drawOn: aCanvas 	"self new openInWorld"	|   point h pointEye h2 head |	h := self height //3.	h2 := self height //5.	point :=  (self direction x * h)@(self direction y * h).	pointEye := (self direction x * 2)@(self direction y * 2).	2 to: 10 do: [:i | 					aCanvas 						fillOval: (self bounds topLeft + (4 @ 4) + i										extent: self height - 7 - (i *2))						color: (Color 									r: i * 0.1 * color red									g: i * 0.1 * color green 									b: i * 0.1 * color blue)].	head := (Rectangle center: (self bounds center + point) extent: h).	aCanvas		fillOval: head		color: Color yellow darker.	aCanvas		fillOval: (Rectangle center: (head center + pointEye) extent: h2)		color: Color black.! !!Miner methodsFor: 'drawing' stamp: 'sd 12/26/2002 12:41'!drawOnOld: aCanvas 	"self new openInWorld"	|   point h pointEye h2 head |	h := self height //3.	h2 := self height //5.	point :=  (self direction x * h)@(self direction y * h).	pointEye := (self direction x * 2)@(self direction y * 2).	2 to: 10 do: [:i | 					aCanvas 						fillOval: (self bounds topLeft + (5 @ 5) + i										extent: self height - 10 - (i *2))						color: (Color 									r: i * 0.1 * color red									g: i * 0.1 * color green 									b: i * 0.1 * color blue)].	head := (Rectangle center: (self bounds center + point) extent: h).	aCanvas		fillOval: head		color: Color yellow darker.	aCanvas		fillOval: (Rectangle center: (head center + pointEye) extent: h2)		color: Color black.! !!Miner methodsFor: 'initialize' stamp: 'sd 12/16/2002 08:54'!autoName	self name: 'b' , self class botCounter asString! !!Miner methodsFor: 'initialize' stamp: 'sd 4/5/2003 10:09'!initialize	"self new openInWorld"		super initialize.	self color: self class nextColor.	self extent: MinerWorld defaultTileSize.	botWorldPosition := 1 @ 1.	self north.	self autoName.	diamNumber := 0. "No noise when bot is loaded"	vars := Dictionary new.	self otherInitialize! !!Miner methodsFor: 'initialize' stamp: 'sd 4/1/2003 11:19'!otherInitialize	"hook so that people can savely extend the robot"		self ! !!Miner methodsFor: 'morph' stamp: 'sd 12/23/2002 15:13'!balloonFeedback	| stream |	stream := ReadWriteStream with: (String new: 10).	stream		nextPutAll: self name;		nextPutAll: ' ';		nextPutAll: 'position: ';		nextPutAll: botWorldPosition asString;		nextPutAll: ' diams: ';		nextPutAll: self diamNumber asString.	self balloonFont: (StrikeFont familyName: #ComicPlain size: 18).	self balloonColor: ((Color 				r: 1.0				g: 1.0				b: 0.6) alpha: 0.7).	self setBalloonText: stream contents! !!Miner methodsFor: 'morph' stamp: 'sd 12/20/2002 17:04'!delete	super delete.	botWorld isNil		ifFalse: [botWorld removeMiner: self.]! !!Miner methodsFor: 'morph' stamp: 'sd 2/12/2002 10:23'!handlesMouseOver: evt 	"true means that the morph can react when the mouse passes over it"	^ true! !!Miner methodsFor: 'morph' stamp: 'sd 2/12/2002 10:29'!mouseEnter: evt 	"Provide feedback when the mouse enter the turtle"	self balloonFeedback! !!Miner methodsFor: 'operations' stamp: 'sd 2/17/2002 13:55'!east	(Delay forMilliseconds: 100).	self direction: self eastEncoding ! !!Miner methodsFor: 'operations' stamp: 'sd 4/4/2003 21:09'!go	"Move the bot one tile in the current direction without 	checking wether it is possible. Raise an error if there is a 	problem "		| nextPosition |	nextPosition := self nextPosition.	(self isNextMoveInWorld: nextPosition)		ifFalse: [self bumpSound.			^ self error: 'Alert bot out of limits!!'].	self isWallInFront		ifTrue: [self bumpSound.			self error: 'Alert bot bumped into a brick!!']		ifFalse: [self goTo: nextPosition.			World doOneCycle.			self motorSound]! !!Miner methodsFor: 'operations' stamp: 'sd 12/24/2002 21:03'!home	botWorld positionTile: self for: botWorld startingPlace! !!Miner methodsFor: 'operations' stamp: 'sd 2/17/2002 13:55'!north	(Delay forMilliseconds: 100).	self direction: self northEncoding! !!Miner methodsFor: 'operations' stamp: 'sd 4/9/2003 13:24'!pointRandomly	"The receiver points in random direction"		self direction: self randomDirection! !!Miner methodsFor: 'operations' stamp: 'sd 2/17/2002 13:55'!south	(Delay forMilliseconds: 100).	self direction: self southEncoding! !!Miner methodsFor: 'operations' stamp: 'sd 2/17/2002 13:56'!west	(Delay forMilliseconds: 100).	self direction: self westEncoding! !!Miner methodsFor: 'painting' stamp: 'sd 4/9/2003 22:00'!paintBlack		self paint: MinerWorldBlackTile! !!Miner methodsFor: 'painting' stamp: 'sd 4/9/2003 22:01'!paintBlue		self paint: MinerWorldGroundTile! !!Miner methodsFor: 'painting' stamp: 'sd 4/9/2003 22:00'!paintGreen		self paint: MinerWorldGreenTile! !!Miner methodsFor: 'painting' stamp: 'sd 4/11/2003 22:25'!paintMagenta		self paint: MinerWorldMagentaTile! !!Miner methodsFor: 'painting' stamp: 'sd 4/9/2003 22:00'!paintYellow		self paint: MinerWorldYellowTile! !!Miner methodsFor: 'printing' stamp: 'sd 12/18/2002 08:59'!printOn: aStream 	aStream nextPutAll: 'Miner '.	self name isNil 		ifFalse: 			[aStream				nextPutAll: self name;				nextPut: Character space].	botWorldPosition isNil 		ifFalse: [aStream nextPutAll: 'w-position: ' , botWorldPosition printString]! !!Miner methodsFor: 'sensors' stamp: 'sd 1/15/2003 14:53'!canMoveForward	"returns true when we can move forward" 		^ (self isNextMoveInWorld: self nextPosition) 		and: [self isWallInFront not]		! !!Miner methodsFor: 'sensors' stamp: 'sd 1/18/2003 22:17'!canMoveLeft	"returns true when we can move left"		^ (self isNextMoveInWorld: self leftPosition)		and: [self isWallOnLeft not]! !!Miner methodsFor: 'sensors' stamp: 'sd 12/24/2002 11:51'!canMoveRight	"returns true when we can move right"		^ (self isNextMoveInWorld: self rightPosition) 		and: [self isWallOnRight not]		! !!Miner methodsFor: 'sensors' stamp: 'sd 4/9/2003 20:15'!isAtHome		^ (botWorld firstTileAt: self botWorldPosition) isStartingTile! !!Miner methodsFor: 'sensors' stamp: 'sd 4/9/2003 20:15'!isOnBlack		^ (botWorld firstTileAt: self botWorldPosition) isBlackTile! !!Miner methodsFor: 'sensors' stamp: 'sd 4/9/2003 22:31'!isOnBlue		^ (botWorld firstTileAt: self botWorldPosition) isGroundTile! !!Miner methodsFor: 'sensors' stamp: 'sd 4/9/2003 20:15'!isOnGreen		^ (botWorld firstTileAt: self botWorldPosition) isGreenTile! !!Miner methodsFor: 'sensors' stamp: 'sd 4/11/2003 22:25'!isOnMagenta		^ (botWorld firstTileAt: self botWorldPosition) isMagentaTile! !!Miner methodsFor: 'sensors' stamp: 'sd 4/9/2003 20:16'!isOnRed		^ (botWorld firstTileAt: self botWorldPosition) isStartingTile! !!Miner methodsFor: 'sensors' stamp: 'sd 4/9/2003 20:16'!isOnYellow		^ (botWorld firstTileAt: self botWorldPosition) isYellowTile! !!Miner methodsFor: 'sounds' stamp: 'sd 4/4/2003 21:09'!bumpSound		BumpSoundOn ifTrue: [	self playSound: 'scratch']! !!Miner methodsFor: 'sounds' stamp: 'sd 4/4/2003 21:10'!dropSound	DropSoundOn ifTrue: [	self playSound: 'scritch']! !!Miner methodsFor: 'sounds' stamp: 'sd 4/4/2003 21:09'!motorSound		MotorSoundOn		ifTrue: [self playSound: 'motor']! !!Miner methodsFor: 'sounds' stamp: 'sd 4/5/2003 10:08'!pickSound		PickSoundOn		ifTrue: [self playSound: 'clink']! !!Miner methodsFor: 'sounds' stamp: 'sd 4/4/2003 20:59'!playSound: aString 		| s |	s := SampledSound soundNamed: aString.	s ifNotNil: [s playAndWaitUntilDone]! !!Miner methodsFor: 'turning' stamp: 'sd 1/18/2003 21:28'!turnLeft		self direction: self leftDirectionEncoding! !!Miner methodsFor: 'turning' stamp: 'sd 1/18/2003 21:21'!turnRight		self direction: self rightDirectionEncoding! !!Miner methodsFor: 'variables' stamp: 'sd 11/20/2003 10:20'!isVariableDefined: aSymbol 	"Tell whether a variable named aSymbol is defined"	^ vars includesKey: aSymbol! !!Miner methodsFor: 'variables' stamp: 'sd 11/20/2003 10:20'!set: aSymbol to: anObject 	"Defines a turtle variable named aSymbol and assign anObject as 	value "	vars at: aSymbol put: anObject! !!Miner methodsFor: 'variables' stamp: 'sd 11/20/2003 10:20'!valueOf: aSymbol 	"Return the value of the variable named aSymbol"		^ vars		at: aSymbol		ifAbsent: [self error: 'the robot variable ' , aSymbol asString , ' is not defined']! !!Miner methodsFor: 'private' stamp: 'sd 2/3/2002 22:42'!eastEncoding	^ 1 @ 0! !!Miner methodsFor: 'private' stamp: 'sd 12/20/2002 17:15'!goTo: aPoint 	botWorldPosition := aPoint.	self position: (botWorld tileAt: aPoint) position! !!Miner methodsFor: 'private' stamp: 'sd 12/21/2002 15:52'!isNextMoveInWorld: aPosition	^ botWorld class worldSize 			containsPoint: aPosition! !!Miner methodsFor: 'private' stamp: 'sd 1/15/2003 14:53'!isWallInFront		^ (self nextTile canPassOverMe: self) not! !!Miner methodsFor: 'private' stamp: 'sd 12/24/2002 11:48'!isWallOnLeft	^(self leftTile canPassOverMe: self) not! !!Miner methodsFor: 'private' stamp: 'sd 12/24/2002 11:47'!isWallOnRight	^(self rightTile canPassOverMe: self) not! !!Miner methodsFor: 'private' stamp: 'sd 12/31/2002 11:54'!leftDirectionEncoding		| dir |	dir := self direction.	^ dir y @ dir x negated	! !!Miner methodsFor: 'private' stamp: 'sd 1/18/2003 22:17'!leftPosition	"returns the position of the left tile taking into account the  	direction of the bot"		^ self leftDirectionEncoding + botWorldPosition! !!Miner methodsFor: 'private' stamp: 'sd 4/9/2003 20:19'!leftTile	"returns the left tile that should be in the world"		^ botWorld firstTileAt: self leftPosition! !!Miner methodsFor: 'private' stamp: 'sd 12/18/2002 09:21'!nextPosition	^ self direction + botWorldPosition! !!Miner methodsFor: 'private' stamp: 'sd 4/9/2003 20:19'!nextTile	"return the next tile that should be in the world"		^ botWorld firstTileAt: self direction + botWorldPosition! !!Miner methodsFor: 'private' stamp: 'sd 2/3/2002 22:42'!northEncoding	^ 0 @ -1! !!Miner methodsFor: 'private' stamp: 'sd 4/9/2003 21:59'!paint: aClass		| pos |	self isAtHome		ifTrue: [^ self].	pos := self botWorldPosition.	self botWorld		replaceTileBy: aClass new openInWorld		atColumn: pos x		row: pos y! !!Miner methodsFor: 'private' stamp: 'sd 4/8/2003 11:05'!randomDirection	"a direction is a point composed by -1,0, or 1 with the constraint  	that  	x * y should always be = to 0"		| x y |	x := 3 atRandom - 2.	y := 3 atRandom - 2.	^ (x * y) isZero		ifTrue: [x @ y]		ifFalse: [self randomDirection]! !!Miner methodsFor: 'private' stamp: 'sd 12/31/2002 11:54'!rightDirectionEncoding		| dir |	dir := self direction.	^ dir y negated @ dir x! !!Miner methodsFor: 'private' stamp: 'sd 1/18/2003 22:17'!rightPosition	"returns the position of the right tile taking into account the  	direction of the bot"		^ self rightDirectionEncoding + botWorldPosition! !!Miner methodsFor: 'private' stamp: 'sd 4/9/2003 20:19'!rightTile	"returns the right tile that should be in the world"		^ botWorld firstTileAt: self rightPosition! !!Miner methodsFor: 'private' stamp: 'sd 2/3/2002 22:42'!southEncoding	^ 0 @1! !!Miner methodsFor: 'private' stamp: 'sd 2/3/2002 22:42'!westEncoding	^ -1 @ 0! !!Miner class methodsFor: 'bot counter' stamp: 'sd 2/10/2002 13:23'!botCounter	botCounter isNil		ifTrue: [botCounter := 0].	^ botCounter! !!Miner class methodsFor: 'bot counter' stamp: 'sd 2/10/2002 13:16'!botCounter: anInteger	botCounter := anInteger! !!Miner class methodsFor: 'bot counter' stamp: 'sd 2/10/2002 13:16'!incrementMinerCounter	self botCounter: self botCounter + 1! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:12'!initialize	"self initialize"		colorIndex := 0.	colorTable := Color				wheel: self maxColor				saturation: 0.6				brightness: 1.	self noisy! !!Miner class methodsFor: 'class initialization' stamp: 'sd 12/23/2002 15:16'!maxColor	^ 8! !!Miner class methodsFor: 'class initialization' stamp: 'sd 12/23/2002 15:35'!nextColor	"computer the next color in the colors"		colorIndex := ((colorIndex + 1) \\ self maxColor) + 1.	^ colorTable at: colorIndex! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:11'!noisy	"all of the robots will make noise"		self noisyMotor.	self noisyDrop.	self noisyPick.	self noisyBump! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:06'!noisyBump		BumpSoundOn := true! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:05'!noisyDrop		DropSoundOn := true! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:04'!noisyMotor	MotorSoundOn := true! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:05'!noisyPick		PickSoundOn :=true! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:11'!silent	"None of the robot will make noise"		self silentMotor.	self silentDrop.	self silentPick.	self silentBump! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:06'!silentBump		BumpSoundOn := false! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:06'!silentDrop		DropSoundOn := false! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:07'!silentMotor		MotorSoundOn := false! !!Miner class methodsFor: 'class initialization' stamp: 'sd 4/4/2003 21:06'!silentPick		PickSoundOn := false! !!Miner class methodsFor: 'instance creation' stamp: 'sd 2/10/2002 13:15'!new	self incrementMinerCounter.	^ super new! !!Miner class methodsFor: 'instance creation' stamp: 'sd 12/23/2002 14:22'!newInMinerWorld: aMinerWorld	"self new openInWorld"		| aMiner |	aMiner := self new.	aMinerWorld addMiner: aMiner. 	^ aMiner! !!MinerSystemWindow methodsFor: 'open/close' stamp: 'sd 12/24/2002 09:05'!botWorldBoard: aMinerWorldBoard	botWorldBoard := aMinerWorldBoard! !!MinerSystemWindow methodsFor: 'open/close' stamp: 'sd 12/24/2002 09:44'!closeBoxHit 	super closeBoxHit.	botWorldBoard removeController: self! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:05'!testCanMove	"(self selector: #testCanMove) run"		self deny: bot canMoveForward.	self assert: bot canMoveLeft.	self assert: bot canMoveRight! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:05'!testCanMove2	"(self selector: #testCanMove2) run"		bot turnLeft.	self assert: bot canMoveForward.	self assert: bot canMoveLeft.	self deny: bot canMoveRight! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:07'!testCanMove3	"(self selector: #testCanMove3) run"		bot turnRight.	self assert: bot canMoveForward.	self deny: bot canMoveLeft.	self assert: bot canMoveRight! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/9/2003 20:26'!testDiamondOnRed	"(self selector: #testDiamondOnRed) run"			self assert: bot isOnRed.	self assert: bot isAtHome.	bot loadDiams: 4.	bot drop.	self assert: bot isOnRed.	self assert: bot isAtHome! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/4/2003 11:49'!testDropDiamond	"(self selector: #testDropDiamond) run"		self assert: bot diamNumber = 0.	bot loadDiams: 1.	self assert: bot diamNumber = 1.	self assert: bot canDrop.	bot drop.	self deny: bot canDrop.	self		should: [bot drop]		raise: Error! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/9/2003 22:36'!testGreenPainted	"(self selector: #testGreenPainted) run"		self deny: bot isOnGreen.	self assert: bot isAtHome.	bot south.	bot go.	self deny: bot isOnRed.	bot paintYellow.	self assert: bot isOnYellow! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/9/2003 22:32'!testIsOnBlue	"(self selector: #testIsOnBlue) run"		bot south.	bot go.	self assert: bot isOnBlue! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/9/2003 20:29'!testIsOnGreen	"(self selector: #testIsOnGreen) run"		self deny: bot isOnGreen.	self assert: bot isAtHome.	bot loadDiams: 4.	bot west.	bot go.	self deny: bot isOnRed.	self assert: bot isOnGreen.	bot drop.	self assert: bot isOnGreen! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:09'!testIsWallOnLeft	"(self selector: #testIsWallOnLeft) run"		self deny: bot isWallOnLeft.	self deny: bot isWallOnRight! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:10'!testIsWallOnLeft2	"(self selector: #testIsWallOnLeft) run"		bot turnLeft.	self deny: bot isWallOnLeft.	self assert: bot isWallOnRight! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:11'!testIsWallOnLeft3	"(self selector: #testIsWallOnLeft) run"		bot turnRight.	self assert: bot isWallOnLeft.	self deny: bot isWallOnRight! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:49'!testLeftTilePosition	"(self selector: #testLeftTilePosition) run"		self assert: bot leftPosition = (9 @ 11).	bot turnRight.	self assert: bot leftPosition = (10 @ 10)! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/9/2003 22:27'!testPaintRedImpossible	"(self selector: #testPaintRedImpossible) run"		self assert: bot isOnRed.	self assert: bot isAtHome.	bot paintYellow.	self assert: bot isOnRed.	self assert: bot isAtHome! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 22:03'!testRightTilePosition	"(self selector: #testRightTilePosition) run"		self assert: bot rightPosition = (11 @ 11).	bot turnLeft.	self assert: bot rightPosition = (10 @ 10)! !!MinerTest methodsFor: 'testing' stamp: 'sd 1/18/2003 21:25'!testTurnRightLeft	"(self selector: #testTurnRightLeft) run"		| dir |	dir := bot direction.	bot turnRight.	bot turnLeft.	self assert: bot direction = dir.	4		timesRepeat: [bot turnRight].	self assert: bot direction = dir! !!MinerTest methodsFor: 'testing' stamp: 'sd 4/1/2003 10:48'!testVar	"(self selector: #testVar) run"		bot set: #count to: 0.	self assert: (bot valueOf: #count) isZero.	self		shouldnt: [bot valueOf: #count]		raise: Error.	bot set: #count to: (bot valueOf: #count)			+ 1.	self assert: (bot valueOf: #count)			= 1.	bot set: #newCount to: 3.	bot set: #count to: (bot valueOf: #count)			+ (bot valueOf: #newCount).	self assert: (bot valueOf: #count)			= 4.	self		should: [bot valueOf: #lulu]		raise: Error.	self assert: (bot isVariableDefined: #count).	self deny: (bot isVariableDefined: #lulu)	! !!MinerTest methodsFor: 'setUp' stamp: 'sd 4/9/2003 20:27'!setUp		Miner silent.	world := MinerWorld newStandAlone installAreaNamed: #oneForTest.	bot := Miner new.	world addMiner: bot! !!MinerWorkspace methodsFor: 'initialize-release' stamp: 'sd 12/24/2002 10:28'!botWorldBoard: aMinerWorldBoard	botWorldBoard := aMinerWorldBoard! !!MinerWorkspace methodsFor: 'initialize-release' stamp: 'sd 12/24/2002 09:56'!embeddedInMorphicWindowLabeled: labelString 	| window |	window := (self windowClass labelled: labelString) model: self.	window addMorph: (self pluggableTextMorphClass 				on: self				text: #contents				accept: #acceptContents:				readSelection: nil				menu: #codePaneMenu:shifted:)		frame: (0 @ 0 corner: 1 @ 1).	^window! !!MinerWorkspace methodsFor: 'initialize-release' stamp: 'sd 12/24/2002 09:57'!pluggableTextMorphClass	^ PluggableTextMorph! !!MinerWorkspace methodsFor: 'initialize-release' stamp: 'sd 12/24/2002 09:57'!windowClass	^ MinerSystemWindow! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 4/9/2003 20:15'!firstTileAt: aPoint 		^ self firstTileAt: aPoint x at: aPoint y! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 4/9/2003 19:20'!firstTileAt: row at: column 	"return the first tile not taking into account diamonds"		^ (area at: column at: row) reverse		detect: [:each | (each isKindOf: MinerWorldDiamond) not]! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 12/17/2002 11:33'!numberOfTiles	^ self columnNumber * self rowNumber! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 12/25/2002 10:14'!remove: anObject at: row at: column		(area at: column at: row) remove: anObject ifAbsent: [nil]! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 12/31/2002 21:04'!startingPlace	"return the starting place the first one found for now"		area do: [:each | (each anySatisfy: [:tile | tile isStartingTile])						ifTrue: [^ each last botWorldPosition]].	^ 1@1! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 12/18/2002 09:11'!tileAt: aPoint	^ self tileAt: aPoint x at: aPoint y! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 12/17/2002 20:46'!tileAt: row at: column	^ (area at: column at: row) last! !!MinerWorld methodsFor: 'accessing' stamp: 'sd 12/17/2002 20:48'!tileAt: row at: column put: anObject	(area at: column at: row) addLast: anObject! !!MinerWorld methodsFor: 'area filling' stamp: 'sd 12/25/2002 11:11'!fillWorldWithGround	"MinerWorld new openInWorld"	1 to: self rowNumber 		do: 			[:currentRow| 				1 to: self columnNumber					do: [:currentColumn |						| tile |						self 						    placeTile: MinerWorldGroundTile newStandAlone 						    atColumn: currentColumn						    row: currentRow]]		! !!MinerWorld methodsFor: 'area filling' stamp: 'sd 12/25/2002 11:12'!installWorld: aDescription 	"Create all the tiles as specified by the description"	| char tile |	1 to: self rowNumber		do: 			[:row | 			1 to: self columnNumber				do: 					[:column | 					char := aDescription at: (self tileDescriptionAtRow: row column: column).					char = MinerWorldGroundTile description 						ifFalse: 							[tile := (self class tileClassFromDescription: char) newStandAlone.							self 								placeTile: tile						    	atColumn: column						    	row: row]]]! !!MinerWorld methodsFor: 'area filling' stamp: 'sd 12/24/2002 19:45'!placeTile: tile atColumn: currentColumn row: currentRow	"place a new tile in the world"			self positionTile: tile for: (currentColumn @ currentRow).	self tileAt: currentColumn at: currentRow put: tile. 	self addMorph: tile		! !!MinerWorld methodsFor: 'area filling' stamp: 'sd 12/25/2002 09:45'!positionTile: aTile for: aPoint 	"place graphically the tile and assign the world coordinates" 		aTile position: self position + (self class defaultTileSize * (aPoint - 1)).	aTile botWorldPosition: aPoint.	aTile botWorld: self! !!MinerWorld methodsFor: 'area filling' stamp: 'sd 4/9/2003 22:55'!replaceTileBy: newTile atColumn: currentColumn row: currentRow 		| oldTile tiles |	self positionTile: newTile for: currentColumn @ currentRow.	oldTile := self firstTileAt: currentColumn @ currentRow.	tiles := area at: currentRow at: currentColumn.	1		to: tiles size		do: [:i | 			(tiles at: i)					== oldTile				ifTrue: [tiles add: newTile afterIndex: i - 1]].	self addMorph: newTile.	oldTile delete.	self botsUpFront! !!MinerWorld methodsFor: 'area filling' stamp: 'sd 12/17/2002 21:53'!tileDescriptionAtRow: aRow column: aColumn	"Return the character description been at the position given by aPoint"    "self new tileDescriptionAtRow: 1 column: 1 ->1"	"self new tileDescriptionAtRow: 2 column: 1 ->17"	"self new tileDescriptionAtRow: 1 column: 2 -> 2 "	"self new tileDescriptionAtRow: 1 column: 3 -> 3"		^ (aColumn + ((aRow-1)*(self columnNumber+1)))! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/24/2002 21:43'!areaIndex: anInteger	anInteger <= areas size		ifTrue: [areaIndex := anInteger]		ifFalse: [areaIndex := anInteger \\ areas size]! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/24/2002 22:28'!completeRestart	self deleteMiners.	self deleteTiles.	self initializeArea.	self initializeMiners.	self fillWorldWithGround.	self installWorld: self currentArea.! !!MinerWorld methodsFor: 'areas' stamp: 'sd 1/15/2003 17:24'!currentArea	^ self class perform: currentSymbol! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/24/2002 14:09'!currentLevelDescription	| aStream |	aStream := ReadWriteStream on: (String new: self tileNumber + self rowNumber).	1 to: self rowNumber 		do: 			[:currentRow| 				1 to: self columnNumber					do: [:currentColumn | 								aStream nextPut: 								(self tileAt: (currentColumn @ currentRow)) class description].				aStream nextPut: Character cr].	^ aStream contents	! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/23/2002 16:58'!deleteMiners	bots do: [:each | each delete].! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/24/2002 21:54'!deleteTiles	area indicesDo: [:row :column | 						(area at: row at: column) do: [:each | (each isKindOf: Miner)																	ifFalse: [each delete]]]! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/25/2002 10:17'!emptyArea	self deleteTiles.	self initializeArea.	self fillWorldWithGround.	! !!MinerWorld methodsFor: 'areas' stamp: 'sd 1/15/2003 17:23'!installAreaNamed: aSymbol 	"aSymbol is the name of a class method of MinerWorld that should	return an area description"	(self class class selectors includes: aSymbol) ifFalse: [^self].	self deleteMiners.	self deleteTiles.	self initializeArea.	self initializeMiners.	self fillWorldWithGround.	currentSymbol := aSymbol.	self installWorld: (self class perform: aSymbol).	! !!MinerWorld methodsFor: 'areas' stamp: 'sd 1/15/2003 17:24'!installCurrentArea	self installWorld: self currentArea! !!MinerWorld methodsFor: 'areas' stamp: 'sd 12/31/2002 21:04'!isValid	"check wether the world has one and 	only one starting place"		| res |	res := OrderedCollection new.	area do: [:each | 				res addAll: 						(each select:							[:tile | tile isStartingTile])].	^ res size = 1	! !!MinerWorld methodsFor: 'areas' stamp: 'sd 1/15/2003 20:29'!restart	self deleteTiles.	self initializeArea.	self fillWorldWithGround.	self installWorld: self currentArea.	self botsAtStartingPlace.	"self botsUpFront"! !!MinerWorld methodsFor: 'bots' stamp: 'sd 12/20/2002 17:05'!addMiner: aMiner	self addMiner: aMiner at: self startingPlace.		! !!MinerWorld methodsFor: 'bots' stamp: 'sd 12/20/2002 17:05'!addMiner: aMiner at: aPoint	self positionTile: aMiner for: aPoint.	aMiner botWorld: self.	bots add: aMiner.	self addMorph: aMiner	! !!MinerWorld methodsFor: 'bots' stamp: 'sd 12/18/2002 21:54'!bots		^ bots! !!MinerWorld methodsFor: 'bots' stamp: 'sd 1/15/2003 20:34'!botsAtStartingPlace	| startPlace |	startPlace := self startingPlace.	bots do: [:each | each goTo: startPlace].	self botsUpFront! !!MinerWorld methodsFor: 'bots' stamp: 'sd 12/25/2002 16:30'!botsUpFront	bots do: [:each | each comeToFront]! !!MinerWorld methodsFor: 'bots' stamp: 'sd 12/20/2002 17:08'!removeMiner: aMiner	bots remove: aMiner ifAbsent: [nil].	aMiner botWorld: nil.	"self removeMorph: aMiner. done via delete"! !!MinerWorld methodsFor: 'default' stamp: 'sd 12/17/2002 20:56'!columnNumber		^ self class columnNumber! !!MinerWorld methodsFor: 'default' stamp: 'sd 12/17/2002 20:56'!rowNumber		^ self class rowNumber! !!MinerWorld methodsFor: 'default' stamp: 'sd 12/17/2002 20:58'!tileNumber		^ self class tileNumber! !!MinerWorld methodsFor: 'diamond' stamp: 'sd 12/23/2002 16:16'!addDiamondAt: aPoint	self 		placeTile: MinerWorldDiamond newStandAlone 		atColumn: aPoint x		row: aPoint y	! !!MinerWorld methodsFor: 'diamond' stamp: 'sd 12/31/2002 21:02'!isDiamondAt: aPoint	^ (self tileAt: aPoint) isDiamondTile	! !!MinerWorld methodsFor: 'diamond' stamp: 'sd 12/25/2002 10:16'!removeDiamondAt: aPoint	| top |	top := (self tileAt: aPoint).	self remove: top at: aPoint x at: aPoint y.	top delete. 	! !!MinerWorld methodsFor: 'drag and drop' stamp: 'sd 12/24/2002 22:35'!acceptDroppingMorph: aMorph event: evt	| pos |	super acceptDroppingMorph: aMorph event: evt.	pos := (self positionToMinerWorldPosition: aMorph position).	self placeTile: aMorph atColumn: pos x row: pos y. 		! !!MinerWorld methodsFor: 'drag and drop' stamp: 'sd 12/24/2002 19:50'!positionToMinerWorldPosition: aPoint	^ ((aPoint - self position + (4@4)) // self class defaultTileSize) + (1@1)! !!MinerWorld methodsFor: 'drag and drop' stamp: 'sd 3/24/2003 21:48'!repelsMorph: aMorph event: ev 		^ (self wantsDroppedMorph: aMorph event: ev) not! !!MinerWorld methodsFor: 'drag and drop' stamp: 'sd 4/9/2003 20:56'!wantsDroppedMorph: aMorph event: evt 	"we cannot put diamond on other tiles in the editor mode"		| tile |	editing ifFalse: [^ editing].	(aMorph isKindOf: MinerWorldTile) ifFalse: [^ false].	tile := (self tileAt: (self positionToMinerWorldPosition: aMorph position)).	^ (tile class = MinerWorldBrick) not		    					"^ editing 		and: [(aMorph isKindOf: MinerWorldTile)				and: [(self						tileAt: (self positionToMinerWorldPosition: aMorph position)) class = MinerWorldGroundTile]]"! !!MinerWorld methodsFor: 'editing' stamp: 'sd 12/25/2002 11:15'!editing	editing := true! !!MinerWorld methodsFor: 'editing' stamp: 'sd 12/25/2002 11:15'!isEditing	^editing! !!MinerWorld methodsFor: 'editing' stamp: 'sd 12/25/2002 11:15'!running	editing := false! !!MinerWorld methodsFor: 'initialization' stamp: 'sd 1/15/2003 17:29'!firstArea	currentSymbol := self class allAreaSelectors at: 1.! !!MinerWorld methodsFor: 'initialization' stamp: 'sd 12/17/2002 13:48'!initializeArea		area := Matrix 				rows: self rowNumber 				columns: self columnNumber.	area indicesDo: [:row :column| area at: row at: column put: OrderedCollection new]! !!MinerWorld methodsFor: 'initialization' stamp: 'sd 12/17/2002 11:15'!initializeBoardLayout	self borderWidth:  2.	self borderColor: Color black.	self color: Color blue muchLighter.	self extent: self class defaultTileSize  * (self columnNumber @ self rowNumber).	! !!MinerWorld methodsFor: 'initialization' stamp: 'sd 12/18/2002 21:52'!initializeMiners	bots := OrderedCollection new! !!MinerWorld methodsFor: 'initialization' stamp: 'sd 1/15/2003 17:31'!initializeToStandAlone		super initializeToStandAlone.	self initializeBoardLayout.	self initializeMiners.	self running.	self initializeArea.	self fillWorldWithGround.	self firstArea. 	self installCurrentArea! !!MinerWorld methodsFor: 'morph events' stamp: 'sd 12/17/2002 12:09'!handlesKeyboard: evt	^ true! !!MinerWorld methodsFor: 'morph events' stamp: 'sd 12/17/2002 12:08'!keyDown: evt	"| char |	char := evt keyCharacter.	char = $n		ifTrue: [batter moveLeft].	char = $m		ifTrue: [batter moveRight]."	"evt hand keyboardFocus: self"	"evet hand releaseKeyboardFocus: self"! !!MinerWorld class methodsFor: 'default' stamp: 'sd 12/26/2002 12:18'!columnNumber	^ 20! !!MinerWorld class methodsFor: 'default' stamp: 'sd 12/26/2002 12:35'!defaultTileSize	^ defaultTileSize! !!MinerWorld class methodsFor: 'default' stamp: 'sd 12/26/2002 12:36'!defaultTileSize: aPoint	 defaultTileSize := aPoint! !!MinerWorld class methodsFor: 'default' stamp: 'sd 12/26/2002 12:17'!rowNumber	^ 17! !!MinerWorld class methodsFor: 'default' stamp: 'sd 12/17/2002 20:58'!tileNumber	^ self columnNumber * self rowNumber! !!MinerWorld class methodsFor: 'default' stamp: 'sd 12/26/2002 12:17'!worldSize	^ 1@1 extent: self columnNumber @ self rowNumber ! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/26/2002 19:47'!area01^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGDDGGGGGGGGGGGGGGGGGDDDDGGGGGGGGGGGGGGGBDDDDBBBBGGGGGGGGGGGGBDDBGGGGBGGGGGGGGGGGBDBDGBBGDBGGGGGGGGGGBGBGGSGBGBGGGGGGGGGABGGBGGGBGBGGGGGGGGGAABDGBBBGGBGGGGGGGGGGAABGGGGGBEGGGGGGGGGGGAABBBBBEGGGGGGGGGGGGGYYYYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 4/1/2003 12:13'!area02  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGDGGGGGGGGGGGGGGGGGGDGDGGGGGGGGGGGGGGGGDGDGDGGGGGGGGGGGGGGDGDGDGDGGGGGGGGGGGGDGDGDGDGDGGGGGGGGGGDGDGDGDGDGDGGGGGGGGDGDGDGDGDGDGDGGGGGGDGDGDGDGDGDGDGGGGGGGGDGDGDGDGDGDGGGGGGGGGGDGDGSGDGDGGGGGGGGGGGGDGDGDGDGGGGGGGGGGGGGGDGDGDGGGGGGGGGGGGGGGGDGDGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/26/2002 19:58'!area03^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGSGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/26/2002 19:59'!area25  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBBBBBBBBBGGGGGGGGGGGBGGGGGGGBGGGGGGBBBBBBGGGGGGGBGGGGGGBGGGGBBBBGGGGBGGGGGGBGGGGBGGBGGGGBGGGGGGBBBGGBGGBGGBBBGGGGGGGGBGGBBBBGGBGGGGGGGGGGBGGGGGGGGBGGGGGGGGGGBGGGGGGGGBGGGGGGGGGGBBBBGGGBBBGGGGGGGGGGGGGGGGGGGGGGGGGGGGBGGGGGGGSGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/28/2002 23:17'!areaMaze  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGBBBBAAABBBGGGGGGGGGGBGGGAAABGGBGGGGGGGGGBBGGGGGBGGBGGGGGGGGGGBGGGGGGGGBGGGGGGGGGGBGGGGGGBBBGGGGGGGBBBBBBGGGBGGBGGGGGGGBGGGGBBBGBGGBGGGGGGGBGGGGGBGGGGGBGGGGGGGBGGGGGGGGGGBGGGGGGGGBBBBBGGGGGGBGGGGGGGGGGGGBBGBGGBGGGGGGGGGGGGGGBGBBBGGGGGGGGGGGGGGGBGBGGGGGGGGGGGGGGGGGBGBGGGGGGGGGGGGGGGGGBSBGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/30/2002 21:53'!areaMiniPath  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGAYGGGGGGGGGGGGGGGGGGGYYGGGGGGGGGGGGGGGGGGGYGGGGGGGGGGGGGGGSYYGYGGGGGGGGGGGGGGGGGYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/31/2002 10:18'!areaMiniPath2  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGAYGGGGGGGGGGGGGGGGGGGYYGGGGGGGGGGGGGGGGGGGYGGGGGGGGGGGGGGSYYYGYGGGGGGGGGGGGGGGGYGYYGGGGGGGGGGGGGGGGYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/31/2002 17:54'!areaMiniPathLeft  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGAGGGGGGGGGGGGGGGGGGGYGGGGGGGGGGGGGGGGGGGYYGGGGGGGGGGGGGGGGGGGYGGGGGGGGGGGGGGGGGGGYYYGGGGGGGGGGGGGGGGGGGYSGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/26/2002 20:01'!areaPath  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGYYYGGGGGGGGGGGGGGGGGYGYGGYYYYYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYYYYGGGYGGGGGYYYYYYGGGGGGGGYGGGGGYGGGGGGGGGGGGGYGGGGGYYYYYASYYYYYYGYGGGGGGGGGGGGGGGGGYGYGGGGGGGGGGGGGGGGGYGYGGGGGGGGGGGGGGGGYYGYGGGGGGGGGGGGGGGGYGGYGGGGGGGGGGGGGGGGYYYYGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/31/2002 17:21'!areaPathFinder3  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGYGGYGGGGGGGGGGGGGGGGYYGYYGGGGGGGGGGGGGGGGYGGYGGGGGGGGGGGGGGSYYYGYGGGGGGGGGGGGGGGGYGYYGGGGGGGGGGGAYYYYYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/31/2002 17:22'!areaPathFinder4  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGYGGYGGGGGGGGGGGGAGGGYYGYYGGGGGGGGGGGYGGGGYGGYGGGGGGGGGGGYYYSYYYGYGGGGGGGGGGGGGGGGYGYYGGGGGGGGGGGGYYYYYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/31/2002 17:20'!areaPathFinderTrap2  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGAGGGGGGGGGGGGGGGGGGGYGGYGGGGGGGGGGGGGGGGYYGYYGGGGGGGGGGGGGGGGYGGYGGGGGGGGGGGGGGSYYYGYGGGGGGGGGGGGGGGGYGYYGGGGGGGGGGGGGGGGYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 12/26/2002 20:03'!areaPathNoBorder  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGYYYGGYYYYYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYGGYGGGYGGGGGGGGGGYGYYYYGGGYGGGGGGYYYYYGGGGGGGGYGGGGGGYGGGGGGGGGGGGYGGGGGGYYYYASYYYYYYGYGGGGGGGGGGGGGGGGGYGYGGGGGGGGGGGGGGGGGYGYGGGGGGGGGGGGGGGGGYGYGGGGGGGGGGGGGGGGGYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 4/8/2003 10:33'!areafoolingAround  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBGBGGGBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBGGGGGBGGBGGGGGGGGGGGGGBGGGGGGGBGGGGGGGGGGGGYGGGYGGGGGGGGGGBGGGGGGGGGGGGBGGGGGGGGBGGGGSGGGBGGGGGGGGGGGGGGGGGGGGGGGGGGGGGBGGGYGGGYGGBGGGGGGGGGGBGGGBGGGGGGGGGGGGGGGGGGGGGGGBGGGGGGGGGGGGBGBGGBGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'areas' stamp: 'sd 4/1/2003 12:12'!areatwo  ^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGDGGGGGGGGGGGGGGGGGGDGDGGGGGGGGGGGGGGGGDGDGDGGGGGGGGGGGGGGDGDGDGDGGGGGGGGGGGGDGDGDGDGDGGGGGGGGGGDGDGDGDGDGDGGGGGGGGDGDGDGDGDGDGDGGGGGGDGDGDGDGDGDGDGGGGGGGGDGDGDGDGDGDGGGGGGGGGGDGDGSGDGDGGGGGGGGGGGGDGDGDGDGGGGGGGGGGGGGGDGDGDGGGGGGGGGGGGGGGGDGDGGGGGGGGG'! !!MinerWorld class methodsFor: 'templates' stamp: 'sd 12/24/2002 21:18'!allAreaSelectors	^(self class selectors select: [:each | 'area*' match: each asString]) 		asSortedCollection! !!MinerWorld class methodsFor: 'templates' stamp: 'sd 12/24/2002 21:18'!gatherAllDefinedAreas	| sortedSelector |	sortedSelector := self allAreaSelectors.	^sortedSelector collect: [:levelSel | self perform: levelSel]! !!MinerWorld class methodsFor: 'templates' stamp: 'sd 12/26/2002 19:43'!generateTemplate	"self generateTemplate" 	| aStream |	aStream := ReadWriteStream on: (String new: self tileNumber + self rowNumber).	self rowNumber timesRepeat: [		 self columnNumber timesRepeat: [ aStream nextPut: MinerWorldGroundTile description].		aStream nextPut: Character cr].	aStream nextPut: Character cr.	^ aStream contents	! !!MinerWorld class methodsFor: 'templates' stamp: 'sd 12/17/2002 22:08'!tileClassFromDescription: aCharacter	^ tileDescriptions at: aCharacter! !!MinerWorld class methodsFor: 'initialize' stamp: 'sd 12/26/2002 12:41'!initialize	"self initialize"		self initializeTileDescriptions.	self initializeDefaultTileSize! !!MinerWorld class methodsFor: 'initialize' stamp: 'sd 12/26/2002 12:35'!initializeDefaultTileSize	defaultTileSize := 28@28! !!MinerWorld class methodsFor: 'initialize' stamp: 'sd 12/25/2002 12:36'!initializeTileDescriptions	"self initializeTileDescriptions"		tileDescriptions := Dictionary new.	MinerWorldTile allSubclasses 		do: [:each | tileDescriptions at: each description put: each]! !!MinerWorld class methodsFor: 'forTests' stamp: 'sd 4/1/2003 12:40'!forTest		^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGSGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorld class methodsFor: 'forTests' stamp: 'sd 4/9/2003 20:28'!oneForTest		^ 'GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGDDGGGGGGGGGGGGGGGGGDDDDGGGGGGGGGGGGGGGBDDDDBBBBGGGGGGGGGGGGBDDBGGGGBGGGGGGGGGGGBDBDGBBGDBGGGGGGGGGGBGBGESGBGBGGGGGGGGGABGGBGGGBGBGGGGGGGGGAABDGBBBGGBGGGGGGGGGGAABGGGGGBEGGGGGGGGGGGAABBBBBEGGGGGGGGGGGGGYYYYYYGGGGGGGGGGGGGGGGGGGGGGGGGGGG'! !!MinerWorldBoard methodsFor: 'bot controller' stamp: 'sd 12/23/2002 22:45'!closeMinerController	botController closeBoxHit! !!MinerWorldBoard methodsFor: 'bot controller' stamp: 'sd 12/22/2002 22:18'!closedMinerController	botController := nil! !!MinerWorldBoard methodsFor: 'bot controller' stamp: 'sd 12/24/2002 09:38'!delete		super delete.	botControllers do: [:each | each  closeBoxHit]! !!MinerWorldBoard methodsFor: 'bot management' stamp: 'sd 12/24/2002 10:29'!addMiner	"self new openInWorld"		| names name bot |		[name := FillInTheBlank request: 'Give a new name for your bot' initialAnswer: 'b2'.	name isEmpty ifTrue: [^self].	names := botWorld bots collect: [:each | each name ].	names includes: name] whileTrue.	bot := (Miner newInMinerWorld: botWorld).				bot name: name.	self updateBindings		! !!MinerWorldBoard methodsFor: 'bot management' stamp: 'sd 12/22/2002 22:05'!botBindings	| dict  | 	dict := Dictionary new.	botWorld bots do: [:each | dict at: each name asSymbol put: each].	^ dict! !!MinerWorldBoard methodsFor: 'bot management' stamp: 'sd 12/24/2002 10:42'!openMinerController	"self new openMinerController"		| workspace window |	workspace := MinerWorkspace new contents: ''.	workspace botWorldBoard: self.	window := (workspace embeddedInMorphicWindowLabeled: 'Miner Controller')					setWindowColor: (Color r: 1.0 g: 0.6 b: 0.0);					openInWorld: World extent: 389@209.	window botWorldBoard: self.	botControllers add: window.	self updateBindings.	! !!MinerWorldBoard methodsFor: 'bot management' stamp: 'sd 12/24/2002 20:04'!removeController: aController	botControllers remove: aController ifAbsent: [nil]	! !!MinerWorldBoard methodsFor: 'bot management' stamp: 'sd 12/24/2002 10:33'!updateBindings	| bindings |	bindings := self botBindings.	botControllers do: [:each | each model setBindings: bindings].! !!MinerWorldBoard methodsFor: 'utilities' stamp: 'sd 12/24/2002 22:28'!completeRestart	botWorld completeRestart! !!MinerWorldBoard methodsFor: 'utilities' stamp: 'sd 1/15/2003 17:17'!createBar	| bar | 	bar := RectangleMorph new.	bar color: color.	bar borderColor: color.	bar borderWidth: 2.	bar layoutPolicy: TableLayout new.	bar listDirection: #leftToRight. 	bar hResizing: #shrinkWrap ;vResizing: #shrinkWrap.	bar  cellInset: 10.	bar addMorph: (self createButtonLabel: 'Quit' target: self actionSelector: #delete). 	bar addMorph: (self createButtonLabel: 'Pick Area' target: self 	actionSelector: #selectingArea).	bar addMorph: (self createButtonLabel: 'Restart' target: self actionSelector: #restart).	bar addMorph: (self createButtonLabel: 'Controller' target: self 	actionSelector: #openMinerController).	bar addMorph: (self createButtonLabel: 'Add Robot' target: self 	actionSelector: #addMiner).			^ bar	! !!MinerWorldBoard methodsFor: 'utilities' stamp: 'sd 12/22/2002 11:57'!createButtonLabel: label target: target actionSelector: sel	^ SimpleButtonMorph new			target: target;			label: label;			actionSelector: sel;			borderColor: #raised;			borderWidth: 2;			color: color muchLighter.! !!MinerWorldBoard methodsFor: 'utilities' stamp: 'sd 12/24/2002 12:39'!nextLevelNamed	| name | 	name := (FillInTheBlank request: 'Name of the next level' initialAnswer: 'area01').	name isEmpty		ifTrue: [^ self]		ifFalse: [botWorld installAreaNamed: name asSymbol]! !!MinerWorldBoard methodsFor: 'utilities' stamp: 'sd 12/24/2002 22:03'!restart	botWorld restart! !!MinerWorldBoard methodsFor: 'utilities' stamp: 'sd 12/24/2002 21:18'!selectingArea	| defined res |	defined := MinerWorld allAreaSelectors.	res := (PopUpMenu labelArray: defined) startUpWithCaption: 'Defined area'.	res isZero 		ifTrue: [^self]		ifFalse: [botWorld installAreaNamed: (defined at: res)]! !!MinerWorldBoard methodsFor: 'initialization' stamp: 'sd 12/24/2002 14:45'!defaultBoardColor	^Color orange! !!MinerWorldBoard methodsFor: 'initialization' stamp: 'sd 12/22/2002 11:45'!initializeMinerWorld	botWorld := MinerWorld newStandAlone.	self addMorph: botWorld	! !!MinerWorldBoard methodsFor: 'initialization' stamp: 'sd 12/24/2002 14:45'!initializeMinerWorldBoardProperties	self layoutPolicy: TableLayout new.	self layoutInset: 1 @ 1.	self borderColor: Color orange lighter.	self		listDirection: #topToBottom;		wrapDirection: #none.	self		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	color := self defaultBoardColor! !!MinerWorldBoard methodsFor: 'initialization' stamp: 'sd 12/24/2002 09:38'!initializeControllers	botControllers := OrderedCollection new	! !!MinerWorldBoard methodsFor: 'initialization' stamp: 'sd 12/24/2002 09:38'!initializeToStandAlone	"MinerWorldBoard newStandAlone openInWorld"	super initializeToStandAlone. 	self initializeMinerWorldBoardProperties.	self addMorph: self createBar.	self initializeControllers.	self initializeMinerWorld.		! !!MinerWorldBoard class methodsFor: 'as yet unclassified' stamp: 'sd 12/28/2002 18:29'!new	^ self newStandAlone! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 12/25/2002 10:18'!createBar	| bar | 	bar := RectangleMorph new.	bar color: color.	bar borderColor: color.	bar borderWidth: 2.	bar layoutPolicy: TableLayout new.	bar listDirection: #leftToRight. 	bar hResizing: #shrinkWrap ;vResizing: #shrinkWrap.	bar  cellInset: 10.	bar addMorph: (self createButtonLabel: 'Save Area' target: self actionSelector: #save). 	bar addMorph: (self createButtonLabel: 'Area Named' target: self 	actionSelector: #nextLevelNamed).	bar addMorph: (self createButtonLabel: 'Pick Area' target: self 	actionSelector: #selectingArea).	bar addMorph: (self createButtonLabel: 'Empty' target: self 	actionSelector: #emptyArea).	bar addMorph: (self createButtonLabel: 'Open Tile Pane' target: self 	actionSelector: #openTilePane).			^ bar	! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 12/24/2002 14:51'!defaultBoardColor	^ Color blue muchLighter! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 12/25/2002 10:18'!emptyArea	botWorld emptyArea! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 12/25/2002 11:25'!initializeToStandAlone	color := Color blue.	super initializeToStandAlone.	self borderColor: Color blue.	botWorld editing	! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 12/24/2002 14:19'!openTilePane	MinerWorldTilePane newStandAlone openInWorld! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 1/16/2003 19:51'!save		| res |	botWorld isValid		ifFalse: [PopUpMenu inform: 'There is too much or no starting place (red tile).\\ There should be only one!!' withCRs.			^ self].	res := FillInTheBlank request: 'Give a name for the level' initialAnswer: 'first'.	res isNil		ifTrue: [^ self]		ifFalse: [MinerWorld class compile: 'area',res , '  ^ ' , '''' , botWorld currentLevelDescription , '''' classified: 'areas']! !!MinerWorldBoardEditor methodsFor: 'initialization' stamp: 'sd 12/24/2002 15:34'!selectingArea	| defined res |	defined := ((MinerWorld class organization listAtCategoryNamed: #areas)						asSortedCollection).			res := ((PopUpMenu labelArray: defined)				startUpWithCaption: 'Defined area').	res isZero		ifTrue: [ ^ self ]		ifFalse: [ botWorld installAreaNamed: (defined at: res) ]		! !!MinerWorldTile methodsFor: 'debug' stamp: 'sd 12/24/2002 15:43'!balloonFeedback	| stream |	stream := ReadWriteStream with: (String new: 10).	stream		nextPutAll: 'position: ';		nextPutAll: botWorldPosition asString.	self setBalloonText: stream contents! !!MinerWorldTile methodsFor: 'debug' stamp: 'sd 12/24/2002 20:00'!handlesMouseOver: evt 	"true means that the morph can react when the mouse passes over it"	^ false! !!MinerWorldTile methodsFor: 'debug' stamp: 'sd 12/24/2002 15:44'!mouseEnter: evt 	"Provide feedback when the mouse enter the turtle"	self balloonFeedback! !!MinerWorldTile methodsFor: 'drag and drop' stamp: 'sd 12/25/2002 11:18'!handlesMouseDown: evt	"if there is a world in editing mode"	"if there is no world, I'm in  a pane"	^ botWorld isNil not 		ifTrue: [botWorld isEditing					ifTrue: [true]					ifFalse: [false]]		ifFalse: [true]			! !!MinerWorldTile methodsFor: 'drag and drop' stamp: 'sd 12/25/2002 11:46'!mouseDown: evt	evt shiftPressed		ifTrue: [self delete]	"evt controlKeyPressed"		ifFalse: [evt hand grabMorph: self duplicate] ! !!MinerWorldTile methodsFor: 'drag and drop' stamp: 'sd 3/26/2003 09:44'!rejectDropMorphEvent: evt 		| h |	h := evt hand.	WorldState		addDeferredUIMessage: [h grabMorph: self].	evt wasHandled: true! !!MinerWorldTile methodsFor: 'initialization' stamp: 'sd 12/18/2002 13:43'!initialize	"MinerWorldTile new openInWorld"	super initialize.	self initializeColor.	self extent: MinerWorld defaultTileSize.	self initializeStyle! !!MinerWorldTile methodsFor: 'initialization' stamp: 'sd 12/25/2002 11:08'!initializeColor		self subclassResponsibility! !!MinerWorldTile methodsFor: 'initialization' stamp: 'sd 12/25/2002 11:08'!initializeStyle	self useSquareCorners.	self borderStyle: (BorderStyle complexAltFramed width: 2)! !!MinerWorldTile methodsFor: 'morph' stamp: 'sd 12/25/2002 10:44'!delete	super delete.	botWorld isNil 		ifFalse: [botWorld remove: self at: botWorldPosition x at:  botWorldPosition y]! !!MinerWorldTile methodsFor: 'operations' stamp: 'sd 12/25/2002 09:45'!botWorld: aWorld	botWorld := aWorld! !!MinerWorldTile methodsFor: 'operations' stamp: 'sd 12/18/2002 14:41'!botWorldPosition	^ botWorldPosition! !!MinerWorldTile methodsFor: 'operations' stamp: 'sd 2/3/2002 21:14'!botWorldPosition: aPoint	botWorldPosition := aPoint! !!MinerWorldTile methodsFor: 'operations' stamp: 'sd 2/9/2002 13:19'!canPassOverMe: aMiner	^ true! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:31'!isBlackTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:36'!isBrickTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:36'!isDiamondTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:36'!isGreenTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:37'!isGroundTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 4/11/2003 22:19'!isMagentaTile		^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:37'!isStartingTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:36'!isYellowTile	^ false! !!MinerWorldTile methodsFor: 'testing' stamp: 'sd 12/25/2002 11:04'!paneable	^ true! !!MinerWorldTile methodsFor: 'printing' stamp: 'sd 12/25/2002 11:10'!printOn: aStream 	| clsName |	clsName := self class name.	aStream nextPutAll: (clsName copyFrom: 'MinerWorld' size + 1 to: clsName size).	botWorldPosition isNil 		ifFalse: [aStream nextPutAll: 'w-position: ' , botWorldPosition printString]! !!MinerWorldBlackTile methodsFor: 'initialization' stamp: 'sd 12/25/2002 09:12'!initializeColor	self color: Color black lighter.	self borderColor: Color black! !!MinerWorldBlackTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:39'!isBlackTile	^ true! !!MinerWorldBrick methodsFor: 'operation' stamp: 'sd 2/9/2002 13:20'!canPassOverMe: aMiner	^ false! !!MinerWorldBrick methodsFor: 'initialization' stamp: 'sd 12/18/2002 13:44'!initializeColor	self borderWidth: 6.	self color: (Color 				r: 1.0				g: 0.516				b: 0.355)! !!MinerWorldBrick methodsFor: 'initialization' stamp: 'sd 12/18/2002 13:44'!initializeStyle	self useSquareCorners.	self borderStyle: (BorderStyle complexRaised width: self borderWidth)! !!MinerWorldBrick methodsFor: 'testing' stamp: 'sd 12/31/2002 20:38'!isBrickTile	^ true! !!MinerWorldDiamond methodsFor: 'drawing' stamp: 'sd 12/25/2002 10:13'!drawOn: aCanvas	1 to: 8 do: [:i | 					aCanvas 						fillRectangle: (self bounds topLeft + (5 @ 5) + i										extent: self height - 10 - (i *2))						color: (Color r: i * 0.2 g: i * 0.2 b: i* 0.2)].	! !!MinerWorldDiamond methodsFor: 'initialization' stamp: 'sd 12/25/2002 11:29'!initializeColor	! !!MinerWorldDiamond methodsFor: 'testing' stamp: 'sd 12/31/2002 20:40'!isDiamondTile	^ true! !!MinerWorldGreenTile methodsFor: 'initialization' stamp: 'sd 12/25/2002 09:11'!initializeColor	self color: Color green lighter.	self borderColor: Color green! !!MinerWorldGreenTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:40'!isGreenTile	^ true! !!MinerWorldGroundTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:42'!isGroundTile	^ true! !!MinerWorldGroundTile methodsFor: 'testing' stamp: 'sd 12/25/2002 11:05'!paneable	"should not be put in the tile pane editor"		^ false! !!MinerWorldGroundTile methodsFor: 'drag and drop' stamp: 'sd 12/25/2002 11:07'!handlesMouseDown: evt	^ false! !!MinerWorldGroundTile methodsFor: 'initialization' stamp: 'sd 12/25/2002 11:07'!initializeColor	self color: Color blue lighter.	self borderColor: Color blue muchLighter! !!MinerWorldMagentaTile methodsFor: 'initialization' stamp: 'sd 4/11/2003 22:19'!initializeColor		self color: Color magenta lighter.	self borderColor: Color magenta! !!MinerWorldMagentaTile methodsFor: 'testing' stamp: 'sd 4/11/2003 22:31'!isMagentaTile		^ true! !!MinerWorldStartTile methodsFor: 'initialization' stamp: 'sd 12/18/2002 13:46'!initializeColor	self color: Color red lighter.	self borderColor: Color red! !!MinerWorldStartTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:43'!isStartingTile	^ true! !!MinerWorldTile class methodsFor: 'description' stamp: 'sd 12/25/2002 11:06'!description	"return the character for encoding the tile in area description"		^ self subclassResponsibility! !!MinerWorldTile class methodsFor: 'description' stamp: 'sd 12/25/2002 11:29'!paneable	^ true! !!MinerWorldBlackTile class methodsFor: 'description' stamp: 'sd 12/25/2002 10:21'!description	^ $A! !!MinerWorldBrick class methodsFor: 'description' stamp: 'sd 12/17/2002 21:01'!description	^ $B! !!MinerWorldDiamond class methodsFor: 'description' stamp: 'sd 12/17/2002 21:01'!description		^ $D! !!MinerWorldGreenTile class methodsFor: 'description' stamp: 'sd 12/25/2002 10:22'!description	^ $E! !!MinerWorldGroundTile class methodsFor: 'description' stamp: 'sd 12/25/2002 11:05'!description 	^ $G! !!MinerWorldGroundTile class methodsFor: 'description' stamp: 'sd 12/25/2002 11:28'!paneable	^ false! !!MinerWorldMagentaTile class methodsFor: 'description' stamp: 'sd 4/11/2003 22:19'!description		^ $N! !!MinerWorldStartTile class methodsFor: 'description' stamp: 'sd 12/18/2002 13:29'!description	^ $S! !!MinerWorldTilePane methodsFor: 'initialize' stamp: 'sd 12/25/2002 11:27'!addTiles	"MinerWorldTilePane newStandAlone openInWorld"		MinerWorldTile subclasses do: [:each| 			each paneable				ifTrue: 					[self addMorph: each newStandAlone]]! !!MinerWorldTilePane methodsFor: 'initialize' stamp: 'sd 12/25/2002 12:33'!initializeMinerWorldBoardProperties	self layoutPolicy: TableLayout new.	self layoutInset: 1@1.	self borderColor: Color blue lighter.	self listDirection: #topToBottom ; wrapDirection: #none.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	color := Color blue muchLighter.! !!MinerWorldTilePane methodsFor: 'initialize' stamp: 'sd 12/24/2002 12:25'!initializeToStandAlone	super initializeToStandAlone.	self initializeMinerWorldBoardProperties.	self addTiles.! !!MinerWorldYellowTile methodsFor: 'initialization' stamp: 'sd 12/25/2002 09:11'!initializeColor	self color: Color yellow lighter.	self borderColor: Color yellow! !!MinerWorldYellowTile methodsFor: 'testing' stamp: 'sd 12/31/2002 20:44'!isYellowTile	^ true! !!MinerWorldYellowTile class methodsFor: 'description' stamp: 'sd 12/25/2002 10:21'!description	^ $Y! !!MinerWorldTilePane reorganize!('initialize' addTiles initializeMinerWorldBoardProperties initializeToStandAlone)!!MinerWorldTile class reorganize!('description' description paneable)!!MinerWorldTile reorganize!('debug' balloonFeedback handlesMouseOver: mouseEnter:)('drag and drop' handlesMouseDown: mouseDown: rejectDropMorphEvent:)('initialization' initialize initializeColor initializeStyle)('morph' delete)('operations' botWorld: botWorldPosition botWorldPosition: canPassOverMe:)('testing' isBlackTile isBrickTile isDiamondTile isGreenTile isGroundTile isMagentaTile isStartingTile isYellowTile paneable)('printing' printOn:)!MinerWorld initialize!!MinerWorld class reorganize!('default' columnNumber defaultTileSize defaultTileSize: rowNumber tileNumber worldSize)('areas' area01 area02 area03 area25 areaMaze areaMiniPath areaMiniPath2 areaMiniPathLeft areaPath areaPathFinder3 areaPathFinder4 areaPathFinderTrap2 areaPathNoBorder areafoolingAround areatwo)('templates' allAreaSelectors gatherAllDefinedAreas generateTemplate tileClassFromDescription:)('initialize' initialize initializeDefaultTileSize initializeTileDescriptions)('forTests' forTest oneForTest)!!MinerWorld reorganize!('accessing' firstTileAt: firstTileAt:at: numberOfTiles remove:at:at: startingPlace tileAt: tileAt:at: tileAt:at:put:)('area filling' fillWorldWithGround installWorld: placeTile:atColumn:row: positionTile:for: replaceTileBy:atColumn:row: tileDescriptionAtRow:column:)('areas' areaIndex: completeRestart currentArea currentLevelDescription deleteMiners deleteTiles emptyArea installAreaNamed: installCurrentArea isValid restart)('bots' addMiner: addMiner:at: bots botsAtStartingPlace botsUpFront removeMiner:)('default' columnNumber rowNumber tileNumber)('diamond' addDiamondAt: isDiamondAt: removeDiamondAt:)('drag and drop' acceptDroppingMorph:event: positionToMinerWorldPosition: repelsMorph:event: wantsDroppedMorph:event:)('editing' editing isEditing running)('initialization' firstArea initializeArea initializeBoardLayout initializeMiners initializeToStandAlone)('morph events' handlesKeyboard: keyDown:)!Miner initialize!!Miner reorganize!('accessing' botWorld botWorld: botWorldPosition botWorldPosition: diamNumber direction direction: name name:)('diamonds' canDrop canPick decreaseDiamondNumber drop increaseDiamondNumber loadDiams: pick)('drawing' drawOn1: drawOn: drawOnOld:)('initialize' autoName initialize otherInitialize)('morph' balloonFeedback delete handlesMouseOver: mouseEnter:)('operations' east go home north pointRandomly south west)('painting' paintBlack paintBlue paintGreen paintMagenta paintYellow)('printing' printOn:)('sensors' canMoveForward canMoveLeft canMoveRight isAtHome isOnBlack isOnBlue isOnGreen isOnMagenta isOnRed isOnYellow)('sounds' bumpSound dropSound motorSound pickSound playSound:)('turning' turnLeft turnRight)('variables' isVariableDefined: set:to: valueOf:)('private' eastEncoding goTo: isNextMoveInWorld: isWallInFront isWallOnLeft isWallOnRight leftDirectionEncoding leftPosition leftTile nextPosition nextTile northEncoding paint: randomDirection rightDirectionEncoding rightPosition rightTile southEncoding westEncoding)!