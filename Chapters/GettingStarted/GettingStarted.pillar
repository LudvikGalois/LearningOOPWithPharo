!! Pharo syntax in a nutshell
@cha:started

In this chapter, we start on a simple path to get you to understand the most important parts of the Pharo syntax: ''messages'', ''blocks'' and ''methods''.
This chapter is freely inspired from Sven van Caeckenberghe's gentle syntax introduction, and I thank him for giving me the permission to reuse his ideas.

In Pharo, everything is an ''object'' and computation happens by sending ''messages'' to objects.
Objects are created by sending messages to particular objects named ''classes'', which define the structure and behavior of the objects they create, also known as their instances.


!!!  Simplicity and elegance of messages

Messages are central to computation in Pharo.
While their syntax is quite minimalist, it is very expressive and structures most of the language.

There are three kinds of messages: unary, binary, and keyword-based.

!!!! Sending a message & the receiver

Let’s first look at an example of sending a message to an object:
[[[
'hello' reversed
]]]

What this means is that the message ==reversed== is sent to the literal string =='hello'==.
In fact, the string =='hello'== is called the ''receiver'' of the message; the receiver is always the leftmost part of a message.

@@important The object to which a message is sent is called the ''receiver'' of that message.

!!!! Evaluating code and convention for showing results

In Pharo, code can be evaluated from anywhere you can type and select text; the system provides various interactive ways to evaluate code and look at the result.
In this book, we will show the result of an expression directly after it, using three chevrons ==>>>==.

Evaluating the piece of code in the previous example yields a new string with the same characters in reverse order:
[[[
'hello' reversed
>>> 'olleh'
]]]

!!!! Other messages & return values

Our =='hello'== string understands many other messages than ==reversed==:
[[[
'hello' asUppercase
>>> 'HELLO'
]]]

As the name implies, the ==asUppercase== message returns yet another string =='HELLO'==, which has the same contents as the receiver with each character converted to upper case.
However, messages sent to strings do not always return strings; other kinds of values are possible:
[[[
'hello' first
>>> $h

'hello' size
>>> 5
]]]

The message ==first== returns the first element of the string: a character.
Literal characters in Pharo syntax are expressed by the dollar sign ==$== immediately followed by the character itself.
The message ==size== returns the number of elements in the string, which is an integer.

Strings, characters, integers are objects, because in Pharo ''everything'' is an object.
Also, messages ''always'' return something, even if the returned value is not used.
One might say that a message can return any value, as long as it's an object.

!!!! The selector & unary messages

All messages we saw so far have the same receiver, the string =='hello'==; however, the computations were different because the messages differ by their name, or to use the technical term, by their ''selector''.
In the syntax of a message, the selector always comes right after the receiver; the message-sending syntax is just the white space in between!

Those messages are called ''unary'' because they involve only one object: their receiver; they do not take any arguments.
Syntactically, the selectors of unary messages must be alphabetic words; the convention to make up longer selectors is to use lower camel case, preferring ==asUppercase== to ==as_uppercase== or ==AsUPPERCASE==.

!!!! A first keyword-based message

Messages often need to pass arguments to the receiver so that it can perform its task; this is what keyword-based messages are for.

As an example, instead of using ==first==, we could use the message ==at:==, with an explicit position as a parameter:
[[[
'hello' at: 1
>>>$h
]]]

The selector ==at:== consists of a single keyword that ends with a colon, signifying that it should be followed by an argument; in this case, an integer indicating which element we want to access.
Pharo counts indices starting from 1; therefore the message ==at: 2== will access the second element of the receiver.
[[[
'hello' at: 2
>>>$e
]]]

!!!! Keyword-based messages with multiple arguments

To pass more than one argument, a single message can have as many colon-terminated keywords as necessary, each followed by an argument, like this:
[[[
'hello' copyFrom: 1 to: 3
>>> 'hel'
]]]

This is one single message, whose selector is really ==copyFrom:to:==.
Note how naturally it reads and how, with well-chosen terms, each keyword of the selector documents the argument that follows it.

In the syntax, you are free to use as much white space as needed between the keywords and the arguments, and like unary messages, the convention is to name each keyword using lower camel case.

!!!! Binary messages

Binary messages visually differ from the other two kinds because their selectors can only be composed of symbols.
They always expect a single argument, even though they do not end in a colon.

The main use of binary messages is as arithmetic operations, for instance sending the message ==+== to the integer ==1==, with ==2== as argument:
[[[
1 + 2
]]]

But there are some other widely-used binary messages outside of arithmetics; for example, comma ==,== is the message for string concatenation:
[[[
'Hello' , ' Pharoers'
>>> 'Hello Pharoers'
]]]

Here, the receiver of the message is =='Hello'== and ==' Pharoers'== is the argument.

!!! Which message is executed first?

Pharo uses distinguish between three kind of messages to get a readable syntax. There is one rule that defines which messages is executed first: 
The simpler messages take precedence over the more complex ones, so unary messages are evaluated first, then binary message and finally keyword messages.

@@important The simpler messages take precedence over the more complex ones, so unary messages are evaluated first, then binary message and finally keyword messages.

Here is an example showing how elegant is the syntax when multiple messages are used.

[[[
'string' asUppercase copyFrom: -1 + 2 to: 6 - 3
>>>STR
]]]

Parentheses are used to control the order of evaluation since they are executed first. In the following expression ==('string' asUppercase first: 9 / 3)== is executed first, then the message ==reserved== is sent to the result of the first expression.
[[[
('string' asUppercase first: 9 / 3) reversed
>>> 'RTS'
]]]


Note how you can send messages to the result of an expression: ==copyFrom:to:== and ==first:== were sent to the result of ==asUppercase==. This is called ''chaining messages''.

!!! Sending messages to classes

Classes are an important entry point to create objects. Of course, this is also done by sending messages such as ==new== to the class object itself.
In Pharo, class name are capitalized. The convention is that uppercase variables represents non-local variables i.e., shared globally or betwen a group of classes.
For example we can ask the class ==String== to create an empty string, by just sending it the message ==new==. 

[[[
String new
>>> ''
]]]

 Some classes understand different instance creation messages, like the class ==Float== that understands the message ==pi==.

[[[
Float pi
>>> 3.141592653589793
]]]


!!! Sequence of statements

Multiple statements are separated using a dot, just like sentences. Local variables are declared by writing their lowercase name between vertical bars.


[[[
| anArray |
anArray := Array new: 3.
anArray at: 1 put: true.
anArray at: 2 put: false.
anArray
]]]

The result of the code above is a new array. Indexing is one-based, like normal humans count.
The value of the variable ==anArray== is 
[[[
#(true false nil)
]]]

The literal array syntax for array is ==#( ... )==. The first element is the boolean constant true, the second its counterpart false. Uninitialised elements remain ==nil==, the undefined object constant. In Pharo, there are only six reserved keywords: ==self==, ==super== and ==thisContext== and the objects ==true==, ==false== and ==nil==.

As you can see, assignment is done using ==:=== while the last statement defines the result for the whole program.

!!! About literal objects
In Pharo, everything is an object and most of the time objects are created by sending the message ==new== to a class. In addition the language supports the creation of certain objects in a compact way. For example the expression  ==#(true false nil)== 
is equivalent to the previous snippet using ==Array new...==. 

[[[
#(true false nil)
]]]

In the same way ==$A== is equivalent to ==Character codePoint: 65==

[[[
Character codePoint: 65
>>> $A
]]]

!!! Sending multiple messages to the same object

Often you’ll be sending multiple messages to the same object, to the same receiver. To make this easier, there is some syntactic sugar called a message ''cascade'' using a semicolon. Let us give an example, imagine the following: 

[[[
| aStream |
aStream := (String new: 100) writeStream.
aStream nextPutAll: 'Today, '.
aStream nextPutAll: Date today printString.
aStream contents
>>> 'Today, 28 January 2017'
]]]

We rewrite the previous code snippet as follows: where several messages are all sent to the same receiver ==aStream== without the need to repeat it. 

[[[
| aStream |
aStream := (String new: 100) writeStream.
aStream 
	nextPutAll: 'Today, ';
	nextPutAll: Date today printString;
	contents
>>> 'Today, 28 January 2017'
]]]


Here is another example with a previous code snippet.
[[[
| anArray |
anArray := Array new: 2. 
anArray at: 1 put: true.
anArray at: 2 put: false.
anArray
]]]


[[[
(Array new: 2)
	at: 1 put: true;
	at: 2 put: false;
	yourself
]]]
	
The three indented messages form a cascade, they are all being sent to the same object, the new array. The last message, yourself, is particularly useful in a cascade: it returns the object it is sent to. This is necessary because the result of the before last message send was not the object itself - the ==at:put:== message returns the value assigned.


!!! Blocks

Square brackets ==[== and ==]==  specify ''blocks'' (also known as lexical closures), pieces of code to be executed later on.

In the following example, the adder local variable is assigned a one argument block. The code inside the block describes the variables it accepts ==:x== and the statements to be executed when it is evaluated ==x + 1==. Evaluating a block is done by sending a message, ==value:== with an actual object as argument. The argument gets bound to the variable and the block is executed, resulting in 101.

[[[
| adder |
adder := [ :x | x + 1 ].
adder value: 100
>>> 101
adder value: 200
>>> 201
]]]

@@important Blocks are technical lexical closures. Now in a first understanding, they represent a kind of anonymous methods that can be sorted, passed as arguments and executed on demand using the messages ==value==, ==value:==...

!!! Control structures

Blocks are used to express all control structures, from standard conditionals and loops to the exotic application specific ones, using the normal messaging syntax. For example loops and conditions are all expressed using the message presented previously. Chapter *@cha:syntax* will present more loops and conditional but they are all using the same principle: a block is passed as argument and the loop definition defines when the block should be executed. 

The message ==timesRepeat==: executes multiple time its argument (a block).
Here we multiply by two a number 10 times. 
[[[
n := 1.
10 timesRepeat: [ n := n * 2 ].
n 
>>> 1024
]]]

Conditionals are expressed by sending one of the messages ==ifTrue:==,
==ifFalse:==, ==ifTrue:ifFalse:==, or ==ifFalse:ifTrue:== to the result of a boolean expression.

[[[
(17 * 13 > 220)
	ifTrue: [ 'bigger' ]
	ifFalse: [ 'smaller' ] 
>>>'bigger'
]]]


The message ==do:== allows one to express a loop over a sequence of objects: a block is executed on each of the elements. 

Let us see how we can count the number of character ==i== in a given string. On each character we check 
if the character is an ==$i== and increase the counter value if this is the case. 

[[[
| count |
count := 0.
'Fear is the little-death that brings total obliteration'
	 do: [:c | c == $i ifTrue: [count := count + 1]].
count
>>> 5
]]]

+Reading or editing a method using a code browser. Topleft pane: list of packages then list of classes then protocols then method lists - middle pane: method definition. Last pane: quality assistant>file://figures/allSatisfy.png|width=95|label=fig:allSatisfy+

!!! Methods

Imagine that we want to following behavior: checking that all the objects of a collection holds the given property. 

Here we check that all the numbers in the array are even numbers. 
[[[
#(2 4 8 16 32) allSatisfy: [ :each | each even ]
>>> true
]]]

But the following is false because not all the numbers are odd.  
[[[
#(1 2 3 4 5 6) allSatisfy: [ :each | each odd ]
>>> false
]]]

The message ==allSatisfy:== is one of the many super powerful behavior implemented in Collection. It is called an iterator.

Methods are edited one by one in a code browser, like the one shown in Figure *@fig:allSatisfy*.

The following code is the definition of the method ==allSatisfy:==. The first line specifies the method name, the selector, with names for all arguments. Comments are surrounded by double quotes. Inside a method, ==self== refers to the object itself, the receiver.

Let us explain the implementation of such method. Using the message ==do:== we iterate over all elements of the collection. For each element we execute block (a predicate) that returns a boolean value and act accordingly. As soon as we get a false value, we stop and return an overall false value. If every evaluation gave us true, we passed the whole test and can return ==true== as overal result.

[[[
allSatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."
	self do: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true
]]]

In a method, the receiver (==self==) is the default return value of the whole method. Using a caret (==\^==) a method returns something else or even return earlier. Here is the code of the method ==allSatify:== on the class ==Collection==.
	


!!! Conclusion 

You have three kinds of messages and the simpler are executed prior to more complex one. Hence unary messages are executed before binary and binary before keyword-based messages. 
Blocks are anymous methods that can be pass around and used to define control structures and loops.

You now know enough to read 95\% of Pharo code. Remember, it is all just messages being sent to objects.
